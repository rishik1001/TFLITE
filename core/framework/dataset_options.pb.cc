// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/framework/dataset_options.proto

#include "tensorflow/core/framework/dataset_options.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace tensorflow {
namespace data {
PROTOBUF_CONSTEXPR AutotuneOptions::AutotuneOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.optional_enabled_)*/{}
  , /*decltype(_impl_.optional_cpu_budget_)*/{}
  , /*decltype(_impl_.optional_ram_budget_)*/{}
  , /*decltype(_impl_.optional_autotune_algorithm_)*/{}
  , /*decltype(_impl_.optional_initial_parallelism_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AutotuneOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutotuneOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutotuneOptionsDefaultTypeInternal() {}
  union {
    AutotuneOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutotuneOptionsDefaultTypeInternal _AutotuneOptions_default_instance_;
PROTOBUF_CONSTEXPR CardinalityOptions::CardinalityOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.compute_level_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CardinalityOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CardinalityOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CardinalityOptionsDefaultTypeInternal() {}
  union {
    CardinalityOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CardinalityOptionsDefaultTypeInternal _CardinalityOptions_default_instance_;
PROTOBUF_CONSTEXPR DistributeOptions::DistributeOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.auto_shard_policy_)*/0
  , /*decltype(_impl_.optional_num_devices_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct DistributeOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DistributeOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DistributeOptionsDefaultTypeInternal() {}
  union {
    DistributeOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DistributeOptionsDefaultTypeInternal _DistributeOptions_default_instance_;
PROTOBUF_CONSTEXPR OptimizationOptions::OptimizationOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.optional_apply_default_optimizations_)*/{}
  , /*decltype(_impl_.optional_filter_fusion_)*/{}
  , /*decltype(_impl_.optional_map_and_batch_fusion_)*/{}
  , /*decltype(_impl_.optional_map_and_filter_fusion_)*/{}
  , /*decltype(_impl_.optional_map_fusion_)*/{}
  , /*decltype(_impl_.optional_map_parallelization_)*/{}
  , /*decltype(_impl_.optional_noop_elimination_)*/{}
  , /*decltype(_impl_.optional_parallel_batch_)*/{}
  , /*decltype(_impl_.optional_shuffle_and_repeat_fusion_)*/{}
  , /*decltype(_impl_.optional_filter_parallelization_)*/{}
  , /*decltype(_impl_.optional_inject_prefetch_)*/{}
  , /*decltype(_impl_.optional_seq_interleave_prefetch_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct OptimizationOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OptimizationOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OptimizationOptionsDefaultTypeInternal() {}
  union {
    OptimizationOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OptimizationOptionsDefaultTypeInternal _OptimizationOptions_default_instance_;
PROTOBUF_CONSTEXPR ThreadingOptions::ThreadingOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.optional_max_intra_op_parallelism_)*/{}
  , /*decltype(_impl_.optional_private_threadpool_size_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ThreadingOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreadingOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreadingOptionsDefaultTypeInternal() {}
  union {
    ThreadingOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreadingOptionsDefaultTypeInternal _ThreadingOptions_default_instance_;
PROTOBUF_CONSTEXPR Options::Options(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.framework_type_)*/{}
  , /*decltype(_impl_.distribute_options_)*/nullptr
  , /*decltype(_impl_.optimization_options_)*/nullptr
  , /*decltype(_impl_.threading_options_)*/nullptr
  , /*decltype(_impl_.autotune_options_)*/nullptr
  , /*decltype(_impl_.optional_dataset_name_)*/{}
  , /*decltype(_impl_.optional_deterministic_)*/{}
  , /*decltype(_impl_.optional_slack_)*/{}
  , /*decltype(_impl_.optional_external_state_policy_)*/{}
  , /*decltype(_impl_.optional_symbolic_checkpoint_)*/{}
  , /*decltype(_impl_.optional_warm_start_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct OptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OptionsDefaultTypeInternal() {}
  union {
    Options _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OptionsDefaultTypeInternal _Options_default_instance_;
}  // namespace data
}  // namespace tensorflow
static ::_pb::Metadata file_level_metadata_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto[6];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto = nullptr;

const uint32_t TableStruct_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::AutotuneOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::AutotuneOptions, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::AutotuneOptions, _impl_.optional_enabled_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::AutotuneOptions, _impl_.optional_cpu_budget_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::AutotuneOptions, _impl_.optional_ram_budget_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::AutotuneOptions, _impl_.optional_autotune_algorithm_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::AutotuneOptions, _impl_.optional_initial_parallelism_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::CardinalityOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::CardinalityOptions, _impl_.compute_level_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::DistributeOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::DistributeOptions, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::DistributeOptions, _impl_.auto_shard_policy_),
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::DistributeOptions, _impl_.optional_num_devices_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_.optional_apply_default_optimizations_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_.optional_filter_fusion_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_.optional_map_and_batch_fusion_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_.optional_map_and_filter_fusion_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_.optional_map_fusion_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_.optional_map_parallelization_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_.optional_noop_elimination_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_.optional_parallel_batch_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_.optional_shuffle_and_repeat_fusion_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_.optional_filter_parallelization_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_.optional_inject_prefetch_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::OptimizationOptions, _impl_.optional_seq_interleave_prefetch_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::ThreadingOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::ThreadingOptions, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::ThreadingOptions, _impl_.optional_max_intra_op_parallelism_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::ThreadingOptions, _impl_.optional_private_threadpool_size_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _impl_.framework_type_),
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _impl_.autotune_options_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _impl_.distribute_options_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _impl_.optimization_options_),
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _impl_.threading_options_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _impl_.optional_dataset_name_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _impl_.optional_deterministic_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _impl_.optional_slack_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _impl_.optional_external_state_policy_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _impl_.optional_symbolic_checkpoint_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::data::Options, _impl_.optional_warm_start_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::tensorflow::data::AutotuneOptions)},
  { 16, -1, -1, sizeof(::tensorflow::data::CardinalityOptions)},
  { 23, -1, -1, sizeof(::tensorflow::data::DistributeOptions)},
  { 32, -1, -1, sizeof(::tensorflow::data::OptimizationOptions)},
  { 62, -1, -1, sizeof(::tensorflow::data::ThreadingOptions)},
  { 72, -1, -1, sizeof(::tensorflow::data::Options)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::tensorflow::data::_AutotuneOptions_default_instance_._instance,
  &::tensorflow::data::_CardinalityOptions_default_instance_._instance,
  &::tensorflow::data::_DistributeOptions_default_instance_._instance,
  &::tensorflow::data::_OptimizationOptions_default_instance_._instance,
  &::tensorflow::data::_ThreadingOptions_default_instance_._instance,
  &::tensorflow::data::_Options_default_instance_._instance,
};

const char descriptor_table_protodef_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n/tensorflow/core/framework/dataset_opti"
  "ons.proto\022\017tensorflow.data\032%tensorflow/c"
  "ore/framework/model.proto\"\270\002\n\017AutotuneOp"
  "tions\022\021\n\007enabled\030\001 \001(\010H\000\022\024\n\ncpu_budget\030\002"
  " \001(\005H\001\022\024\n\nram_budget\030\003 \001(\003H\002\022F\n\022autotune"
  "_algorithm\030\004 \001(\0162(.tensorflow.data.model"
  ".AutotuneAlgorithmH\003\022\035\n\023initial_parallel"
  "ism\030\005 \001(\003H\004B\022\n\020optional_enabledB\025\n\023optio"
  "nal_cpu_budgetB\025\n\023optional_ram_budgetB\035\n"
  "\033optional_autotune_algorithmB\036\n\034optional"
  "_initial_parallelism\"\321\001\n\022CardinalityOpti"
  "ons\022G\n\rcompute_level\030\001 \001(\01620.tensorflow."
  "data.CardinalityOptions.ComputeLevel\"r\n\014"
  "ComputeLevel\022#\n\037CARDINALITY_COMPUTE_UNSP"
  "ECIFIED\020\000\022\033\n\027CARDINALITY_COMPUTE_LOW\020\001\022 "
  "\n\034CARDINALITY_COMPUTE_MODERATE\020\002\"\177\n\021Dist"
  "ributeOptions\022;\n\021auto_shard_policy\030\001 \001(\016"
  "2 .tensorflow.data.AutoShardPolicy\022\025\n\013nu"
  "m_devices\030\002 \001(\005H\000B\026\n\024optional_num_device"
  "s\"\271\006\n\023OptimizationOptions\022%\n\033apply_defau"
  "lt_optimizations\030\001 \001(\010H\000\022\027\n\rfilter_fusio"
  "n\030\006 \001(\010H\001\022\036\n\024map_and_batch_fusion\030\t \001(\010H"
  "\002\022\037\n\025map_and_filter_fusion\030\n \001(\010H\003\022\024\n\nma"
  "p_fusion\030\013 \001(\010H\004\022\035\n\023map_parallelization\030"
  "\014 \001(\010H\005\022\032\n\020noop_elimination\030\016 \001(\010H\006\022\030\n\016p"
  "arallel_batch\030\017 \001(\010H\007\022#\n\031shuffle_and_rep"
  "eat_fusion\030\021 \001(\010H\010\022 \n\026filter_paralleliza"
  "tion\030\022 \001(\010H\t\022\031\n\017inject_prefetch\030\023 \001(\010H\n\022"
  "!\n\027seq_interleave_prefetch\030\025 \001(\010H\013B&\n$op"
  "tional_apply_default_optimizationsB\030\n\026op"
  "tional_filter_fusionB\037\n\035optional_map_and"
  "_batch_fusionB \n\036optional_map_and_filter"
  "_fusionB\025\n\023optional_map_fusionB\036\n\034option"
  "al_map_parallelizationB\033\n\031optional_noop_"
  "eliminationB\031\n\027optional_parallel_batchB$"
  "\n\"optional_shuffle_and_repeat_fusionB!\n\037"
  "optional_filter_parallelizationB\032\n\030optio"
  "nal_inject_prefetchB\"\n optional_seq_inte"
  "rleave_prefetchJ\004\010\002\020\003J\004\010\003\020\004J\004\010\004\020\005J\004\010\005\020\006J"
  "\004\010\007\020\010J\004\010\010\020\tJ\004\010\r\020\016J\004\010\020\020\021J\004\010\024\020\025\"\242\001\n\020Thread"
  "ingOptions\022\"\n\030max_intra_op_parallelism\030\001"
  " \001(\005H\000\022!\n\027private_threadpool_size\030\002 \001(\005H"
  "\001B#\n!optional_max_intra_op_parallelismB\""
  "\n optional_private_threadpool_size\"\373\004\n\007O"
  "ptions\022\026\n\014dataset_name\030\n \001(\tH\000\022\026\n\016framew"
  "ork_type\030\013 \003(\t\022\027\n\rdeterministic\030\001 \001(\010H\001\022"
  ":\n\020autotune_options\030\007 \001(\0132 .tensorflow.d"
  "ata.AutotuneOptions\022>\n\022distribute_option"
  "s\030\002 \001(\0132\".tensorflow.data.DistributeOpti"
  "ons\022B\n\024optimization_options\030\003 \001(\0132$.tens"
  "orflow.data.OptimizationOptions\022\017\n\005slack"
  "\030\004 \001(\010H\002\022<\n\021threading_options\030\005 \001(\0132!.te"
  "nsorflow.data.ThreadingOptions\022E\n\025extern"
  "al_state_policy\030\006 \001(\0162$.tensorflow.data."
  "ExternalStatePolicyH\003\022\035\n\023symbolic_checkp"
  "oint\030\010 \001(\010H\004\022\024\n\nwarm_start\030\t \001(\010H\005B\027\n\025op"
  "tional_dataset_nameB\030\n\026optional_determin"
  "isticB\020\n\016optional_slackB \n\036optional_exte"
  "rnal_state_policyB\036\n\034optional_symbolic_c"
  "heckpointB\025\n\023optional_warm_start*K\n\017Auto"
  "ShardPolicy\022\010\n\004AUTO\020\000\022\010\n\004FILE\020\001\022\010\n\004DATA\020"
  "\002\022\010\n\004HINT\020\003\022\020\n\003OFF\020\377\377\377\377\377\377\377\377\377\001*J\n\023Externa"
  "lStatePolicy\022\017\n\013POLICY_WARN\020\000\022\021\n\rPOLICY_"
  "IGNORE\020\001\022\017\n\013POLICY_FAIL\020\002BXZVgithub.com/"
  "tensorflow/tensorflow/tensorflow/go/core"
  "/framework/dataset_options_go_protob\006pro"
  "to3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_deps[1] = {
  &::descriptor_table_tensorflow_2fcore_2fframework_2fmodel_2eproto,
};
static ::_pbi::once_flag descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto = {
    false, false, 2643, descriptor_table_protodef_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto,
    "tensorflow/core/framework/dataset_options.proto",
    &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_once, descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_deps, 1, 6,
    schemas, file_default_instances, TableStruct_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto::offsets,
    file_level_metadata_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto, file_level_enum_descriptors_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto,
    file_level_service_descriptors_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_getter() {
  return &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto(&descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto);
namespace tensorflow {
namespace data {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CardinalityOptions_ComputeLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto);
  return file_level_enum_descriptors_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto[0];
}
bool CardinalityOptions_ComputeLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CardinalityOptions_ComputeLevel CardinalityOptions::CARDINALITY_COMPUTE_UNSPECIFIED;
constexpr CardinalityOptions_ComputeLevel CardinalityOptions::CARDINALITY_COMPUTE_LOW;
constexpr CardinalityOptions_ComputeLevel CardinalityOptions::CARDINALITY_COMPUTE_MODERATE;
constexpr CardinalityOptions_ComputeLevel CardinalityOptions::ComputeLevel_MIN;
constexpr CardinalityOptions_ComputeLevel CardinalityOptions::ComputeLevel_MAX;
constexpr int CardinalityOptions::ComputeLevel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AutoShardPolicy_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto);
  return file_level_enum_descriptors_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto[1];
}
bool AutoShardPolicy_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExternalStatePolicy_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto);
  return file_level_enum_descriptors_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto[2];
}
bool ExternalStatePolicy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class AutotuneOptions::_Internal {
 public:
};

AutotuneOptions::AutotuneOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.data.AutotuneOptions)
}
AutotuneOptions::AutotuneOptions(const AutotuneOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AutotuneOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.optional_enabled_){}
    , decltype(_impl_.optional_cpu_budget_){}
    , decltype(_impl_.optional_ram_budget_){}
    , decltype(_impl_.optional_autotune_algorithm_){}
    , decltype(_impl_.optional_initial_parallelism_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_optional_enabled();
  switch (from.optional_enabled_case()) {
    case kEnabled: {
      _this->_internal_set_enabled(from._internal_enabled());
      break;
    }
    case OPTIONAL_ENABLED_NOT_SET: {
      break;
    }
  }
  clear_has_optional_cpu_budget();
  switch (from.optional_cpu_budget_case()) {
    case kCpuBudget: {
      _this->_internal_set_cpu_budget(from._internal_cpu_budget());
      break;
    }
    case OPTIONAL_CPU_BUDGET_NOT_SET: {
      break;
    }
  }
  clear_has_optional_ram_budget();
  switch (from.optional_ram_budget_case()) {
    case kRamBudget: {
      _this->_internal_set_ram_budget(from._internal_ram_budget());
      break;
    }
    case OPTIONAL_RAM_BUDGET_NOT_SET: {
      break;
    }
  }
  clear_has_optional_autotune_algorithm();
  switch (from.optional_autotune_algorithm_case()) {
    case kAutotuneAlgorithm: {
      _this->_internal_set_autotune_algorithm(from._internal_autotune_algorithm());
      break;
    }
    case OPTIONAL_AUTOTUNE_ALGORITHM_NOT_SET: {
      break;
    }
  }
  clear_has_optional_initial_parallelism();
  switch (from.optional_initial_parallelism_case()) {
    case kInitialParallelism: {
      _this->_internal_set_initial_parallelism(from._internal_initial_parallelism());
      break;
    }
    case OPTIONAL_INITIAL_PARALLELISM_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tensorflow.data.AutotuneOptions)
}

inline void AutotuneOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.optional_enabled_){}
    , decltype(_impl_.optional_cpu_budget_){}
    , decltype(_impl_.optional_ram_budget_){}
    , decltype(_impl_.optional_autotune_algorithm_){}
    , decltype(_impl_.optional_initial_parallelism_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_optional_enabled();
  clear_has_optional_cpu_budget();
  clear_has_optional_ram_budget();
  clear_has_optional_autotune_algorithm();
  clear_has_optional_initial_parallelism();
}

AutotuneOptions::~AutotuneOptions() {
  // @@protoc_insertion_point(destructor:tensorflow.data.AutotuneOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutotuneOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_optional_enabled()) {
    clear_optional_enabled();
  }
  if (has_optional_cpu_budget()) {
    clear_optional_cpu_budget();
  }
  if (has_optional_ram_budget()) {
    clear_optional_ram_budget();
  }
  if (has_optional_autotune_algorithm()) {
    clear_optional_autotune_algorithm();
  }
  if (has_optional_initial_parallelism()) {
    clear_optional_initial_parallelism();
  }
}

void AutotuneOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AutotuneOptions::clear_optional_enabled() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.AutotuneOptions)
  switch (optional_enabled_case()) {
    case kEnabled: {
      // No need to clear
      break;
    }
    case OPTIONAL_ENABLED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = OPTIONAL_ENABLED_NOT_SET;
}

void AutotuneOptions::clear_optional_cpu_budget() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.AutotuneOptions)
  switch (optional_cpu_budget_case()) {
    case kCpuBudget: {
      // No need to clear
      break;
    }
    case OPTIONAL_CPU_BUDGET_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = OPTIONAL_CPU_BUDGET_NOT_SET;
}

void AutotuneOptions::clear_optional_ram_budget() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.AutotuneOptions)
  switch (optional_ram_budget_case()) {
    case kRamBudget: {
      // No need to clear
      break;
    }
    case OPTIONAL_RAM_BUDGET_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = OPTIONAL_RAM_BUDGET_NOT_SET;
}

void AutotuneOptions::clear_optional_autotune_algorithm() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.AutotuneOptions)
  switch (optional_autotune_algorithm_case()) {
    case kAutotuneAlgorithm: {
      // No need to clear
      break;
    }
    case OPTIONAL_AUTOTUNE_ALGORITHM_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = OPTIONAL_AUTOTUNE_ALGORITHM_NOT_SET;
}

void AutotuneOptions::clear_optional_initial_parallelism() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.AutotuneOptions)
  switch (optional_initial_parallelism_case()) {
    case kInitialParallelism: {
      // No need to clear
      break;
    }
    case OPTIONAL_INITIAL_PARALLELISM_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = OPTIONAL_INITIAL_PARALLELISM_NOT_SET;
}


void AutotuneOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.data.AutotuneOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_optional_enabled();
  clear_optional_cpu_budget();
  clear_optional_ram_budget();
  clear_optional_autotune_algorithm();
  clear_optional_initial_parallelism();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AutotuneOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_enabled(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 cpu_budget = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_cpu_budget(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 ram_budget = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_ram_budget(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.data.model.AutotuneAlgorithm autotune_algorithm = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_autotune_algorithm(static_cast<::tensorflow::data::model::AutotuneAlgorithm>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 initial_parallelism = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _internal_set_initial_parallelism(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutotuneOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.data.AutotuneOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enabled = 1;
  if (_internal_has_enabled()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // int32 cpu_budget = 2;
  if (_internal_has_cpu_budget()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_cpu_budget(), target);
  }

  // int64 ram_budget = 3;
  if (_internal_has_ram_budget()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_ram_budget(), target);
  }

  // .tensorflow.data.model.AutotuneAlgorithm autotune_algorithm = 4;
  if (_internal_has_autotune_algorithm()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_autotune_algorithm(), target);
  }

  // int64 initial_parallelism = 5;
  if (_internal_has_initial_parallelism()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_initial_parallelism(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.data.AutotuneOptions)
  return target;
}

size_t AutotuneOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.data.AutotuneOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (optional_enabled_case()) {
    // bool enabled = 1;
    case kEnabled: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_ENABLED_NOT_SET: {
      break;
    }
  }
  switch (optional_cpu_budget_case()) {
    // int32 cpu_budget = 2;
    case kCpuBudget: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cpu_budget());
      break;
    }
    case OPTIONAL_CPU_BUDGET_NOT_SET: {
      break;
    }
  }
  switch (optional_ram_budget_case()) {
    // int64 ram_budget = 3;
    case kRamBudget: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ram_budget());
      break;
    }
    case OPTIONAL_RAM_BUDGET_NOT_SET: {
      break;
    }
  }
  switch (optional_autotune_algorithm_case()) {
    // .tensorflow.data.model.AutotuneAlgorithm autotune_algorithm = 4;
    case kAutotuneAlgorithm: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_autotune_algorithm());
      break;
    }
    case OPTIONAL_AUTOTUNE_ALGORITHM_NOT_SET: {
      break;
    }
  }
  switch (optional_initial_parallelism_case()) {
    // int64 initial_parallelism = 5;
    case kInitialParallelism: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_initial_parallelism());
      break;
    }
    case OPTIONAL_INITIAL_PARALLELISM_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AutotuneOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AutotuneOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AutotuneOptions::GetClassData() const { return &_class_data_; }


void AutotuneOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AutotuneOptions*>(&to_msg);
  auto& from = static_cast<const AutotuneOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.data.AutotuneOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.optional_enabled_case()) {
    case kEnabled: {
      _this->_internal_set_enabled(from._internal_enabled());
      break;
    }
    case OPTIONAL_ENABLED_NOT_SET: {
      break;
    }
  }
  switch (from.optional_cpu_budget_case()) {
    case kCpuBudget: {
      _this->_internal_set_cpu_budget(from._internal_cpu_budget());
      break;
    }
    case OPTIONAL_CPU_BUDGET_NOT_SET: {
      break;
    }
  }
  switch (from.optional_ram_budget_case()) {
    case kRamBudget: {
      _this->_internal_set_ram_budget(from._internal_ram_budget());
      break;
    }
    case OPTIONAL_RAM_BUDGET_NOT_SET: {
      break;
    }
  }
  switch (from.optional_autotune_algorithm_case()) {
    case kAutotuneAlgorithm: {
      _this->_internal_set_autotune_algorithm(from._internal_autotune_algorithm());
      break;
    }
    case OPTIONAL_AUTOTUNE_ALGORITHM_NOT_SET: {
      break;
    }
  }
  switch (from.optional_initial_parallelism_case()) {
    case kInitialParallelism: {
      _this->_internal_set_initial_parallelism(from._internal_initial_parallelism());
      break;
    }
    case OPTIONAL_INITIAL_PARALLELISM_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AutotuneOptions::CopyFrom(const AutotuneOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.data.AutotuneOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutotuneOptions::IsInitialized() const {
  return true;
}

void AutotuneOptions::InternalSwap(AutotuneOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.optional_enabled_, other->_impl_.optional_enabled_);
  swap(_impl_.optional_cpu_budget_, other->_impl_.optional_cpu_budget_);
  swap(_impl_.optional_ram_budget_, other->_impl_.optional_ram_budget_);
  swap(_impl_.optional_autotune_algorithm_, other->_impl_.optional_autotune_algorithm_);
  swap(_impl_.optional_initial_parallelism_, other->_impl_.optional_initial_parallelism_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AutotuneOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto[0]);
}

// ===================================================================

class CardinalityOptions::_Internal {
 public:
};

CardinalityOptions::CardinalityOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.data.CardinalityOptions)
}
CardinalityOptions::CardinalityOptions(const CardinalityOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CardinalityOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.compute_level_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.compute_level_ = from._impl_.compute_level_;
  // @@protoc_insertion_point(copy_constructor:tensorflow.data.CardinalityOptions)
}

inline void CardinalityOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.compute_level_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CardinalityOptions::~CardinalityOptions() {
  // @@protoc_insertion_point(destructor:tensorflow.data.CardinalityOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CardinalityOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CardinalityOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CardinalityOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.data.CardinalityOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.compute_level_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CardinalityOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tensorflow.data.CardinalityOptions.ComputeLevel compute_level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_compute_level(static_cast<::tensorflow::data::CardinalityOptions_ComputeLevel>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CardinalityOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.data.CardinalityOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tensorflow.data.CardinalityOptions.ComputeLevel compute_level = 1;
  if (this->_internal_compute_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_compute_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.data.CardinalityOptions)
  return target;
}

size_t CardinalityOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.data.CardinalityOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tensorflow.data.CardinalityOptions.ComputeLevel compute_level = 1;
  if (this->_internal_compute_level() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_compute_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CardinalityOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CardinalityOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CardinalityOptions::GetClassData() const { return &_class_data_; }


void CardinalityOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CardinalityOptions*>(&to_msg);
  auto& from = static_cast<const CardinalityOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.data.CardinalityOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_compute_level() != 0) {
    _this->_internal_set_compute_level(from._internal_compute_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CardinalityOptions::CopyFrom(const CardinalityOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.data.CardinalityOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CardinalityOptions::IsInitialized() const {
  return true;
}

void CardinalityOptions::InternalSwap(CardinalityOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.compute_level_, other->_impl_.compute_level_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CardinalityOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto[1]);
}

// ===================================================================

class DistributeOptions::_Internal {
 public:
};

DistributeOptions::DistributeOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.data.DistributeOptions)
}
DistributeOptions::DistributeOptions(const DistributeOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DistributeOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.auto_shard_policy_){}
    , decltype(_impl_.optional_num_devices_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.auto_shard_policy_ = from._impl_.auto_shard_policy_;
  clear_has_optional_num_devices();
  switch (from.optional_num_devices_case()) {
    case kNumDevices: {
      _this->_internal_set_num_devices(from._internal_num_devices());
      break;
    }
    case OPTIONAL_NUM_DEVICES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tensorflow.data.DistributeOptions)
}

inline void DistributeOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.auto_shard_policy_){0}
    , decltype(_impl_.optional_num_devices_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_optional_num_devices();
}

DistributeOptions::~DistributeOptions() {
  // @@protoc_insertion_point(destructor:tensorflow.data.DistributeOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DistributeOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_optional_num_devices()) {
    clear_optional_num_devices();
  }
}

void DistributeOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DistributeOptions::clear_optional_num_devices() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.DistributeOptions)
  switch (optional_num_devices_case()) {
    case kNumDevices: {
      // No need to clear
      break;
    }
    case OPTIONAL_NUM_DEVICES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = OPTIONAL_NUM_DEVICES_NOT_SET;
}


void DistributeOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.data.DistributeOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.auto_shard_policy_ = 0;
  clear_optional_num_devices();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DistributeOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tensorflow.data.AutoShardPolicy auto_shard_policy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_auto_shard_policy(static_cast<::tensorflow::data::AutoShardPolicy>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 num_devices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_num_devices(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DistributeOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.data.DistributeOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tensorflow.data.AutoShardPolicy auto_shard_policy = 1;
  if (this->_internal_auto_shard_policy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_auto_shard_policy(), target);
  }

  // int32 num_devices = 2;
  if (_internal_has_num_devices()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_devices(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.data.DistributeOptions)
  return target;
}

size_t DistributeOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.data.DistributeOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tensorflow.data.AutoShardPolicy auto_shard_policy = 1;
  if (this->_internal_auto_shard_policy() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_auto_shard_policy());
  }

  switch (optional_num_devices_case()) {
    // int32 num_devices = 2;
    case kNumDevices: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_devices());
      break;
    }
    case OPTIONAL_NUM_DEVICES_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DistributeOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DistributeOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DistributeOptions::GetClassData() const { return &_class_data_; }


void DistributeOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DistributeOptions*>(&to_msg);
  auto& from = static_cast<const DistributeOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.data.DistributeOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_auto_shard_policy() != 0) {
    _this->_internal_set_auto_shard_policy(from._internal_auto_shard_policy());
  }
  switch (from.optional_num_devices_case()) {
    case kNumDevices: {
      _this->_internal_set_num_devices(from._internal_num_devices());
      break;
    }
    case OPTIONAL_NUM_DEVICES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DistributeOptions::CopyFrom(const DistributeOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.data.DistributeOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DistributeOptions::IsInitialized() const {
  return true;
}

void DistributeOptions::InternalSwap(DistributeOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.auto_shard_policy_, other->_impl_.auto_shard_policy_);
  swap(_impl_.optional_num_devices_, other->_impl_.optional_num_devices_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata DistributeOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto[2]);
}

// ===================================================================

class OptimizationOptions::_Internal {
 public:
};

OptimizationOptions::OptimizationOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.data.OptimizationOptions)
}
OptimizationOptions::OptimizationOptions(const OptimizationOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OptimizationOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.optional_apply_default_optimizations_){}
    , decltype(_impl_.optional_filter_fusion_){}
    , decltype(_impl_.optional_map_and_batch_fusion_){}
    , decltype(_impl_.optional_map_and_filter_fusion_){}
    , decltype(_impl_.optional_map_fusion_){}
    , decltype(_impl_.optional_map_parallelization_){}
    , decltype(_impl_.optional_noop_elimination_){}
    , decltype(_impl_.optional_parallel_batch_){}
    , decltype(_impl_.optional_shuffle_and_repeat_fusion_){}
    , decltype(_impl_.optional_filter_parallelization_){}
    , decltype(_impl_.optional_inject_prefetch_){}
    , decltype(_impl_.optional_seq_interleave_prefetch_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_optional_apply_default_optimizations();
  switch (from.optional_apply_default_optimizations_case()) {
    case kApplyDefaultOptimizations: {
      _this->_internal_set_apply_default_optimizations(from._internal_apply_default_optimizations());
      break;
    }
    case OPTIONAL_APPLY_DEFAULT_OPTIMIZATIONS_NOT_SET: {
      break;
    }
  }
  clear_has_optional_filter_fusion();
  switch (from.optional_filter_fusion_case()) {
    case kFilterFusion: {
      _this->_internal_set_filter_fusion(from._internal_filter_fusion());
      break;
    }
    case OPTIONAL_FILTER_FUSION_NOT_SET: {
      break;
    }
  }
  clear_has_optional_map_and_batch_fusion();
  switch (from.optional_map_and_batch_fusion_case()) {
    case kMapAndBatchFusion: {
      _this->_internal_set_map_and_batch_fusion(from._internal_map_and_batch_fusion());
      break;
    }
    case OPTIONAL_MAP_AND_BATCH_FUSION_NOT_SET: {
      break;
    }
  }
  clear_has_optional_map_and_filter_fusion();
  switch (from.optional_map_and_filter_fusion_case()) {
    case kMapAndFilterFusion: {
      _this->_internal_set_map_and_filter_fusion(from._internal_map_and_filter_fusion());
      break;
    }
    case OPTIONAL_MAP_AND_FILTER_FUSION_NOT_SET: {
      break;
    }
  }
  clear_has_optional_map_fusion();
  switch (from.optional_map_fusion_case()) {
    case kMapFusion: {
      _this->_internal_set_map_fusion(from._internal_map_fusion());
      break;
    }
    case OPTIONAL_MAP_FUSION_NOT_SET: {
      break;
    }
  }
  clear_has_optional_map_parallelization();
  switch (from.optional_map_parallelization_case()) {
    case kMapParallelization: {
      _this->_internal_set_map_parallelization(from._internal_map_parallelization());
      break;
    }
    case OPTIONAL_MAP_PARALLELIZATION_NOT_SET: {
      break;
    }
  }
  clear_has_optional_noop_elimination();
  switch (from.optional_noop_elimination_case()) {
    case kNoopElimination: {
      _this->_internal_set_noop_elimination(from._internal_noop_elimination());
      break;
    }
    case OPTIONAL_NOOP_ELIMINATION_NOT_SET: {
      break;
    }
  }
  clear_has_optional_parallel_batch();
  switch (from.optional_parallel_batch_case()) {
    case kParallelBatch: {
      _this->_internal_set_parallel_batch(from._internal_parallel_batch());
      break;
    }
    case OPTIONAL_PARALLEL_BATCH_NOT_SET: {
      break;
    }
  }
  clear_has_optional_shuffle_and_repeat_fusion();
  switch (from.optional_shuffle_and_repeat_fusion_case()) {
    case kShuffleAndRepeatFusion: {
      _this->_internal_set_shuffle_and_repeat_fusion(from._internal_shuffle_and_repeat_fusion());
      break;
    }
    case OPTIONAL_SHUFFLE_AND_REPEAT_FUSION_NOT_SET: {
      break;
    }
  }
  clear_has_optional_filter_parallelization();
  switch (from.optional_filter_parallelization_case()) {
    case kFilterParallelization: {
      _this->_internal_set_filter_parallelization(from._internal_filter_parallelization());
      break;
    }
    case OPTIONAL_FILTER_PARALLELIZATION_NOT_SET: {
      break;
    }
  }
  clear_has_optional_inject_prefetch();
  switch (from.optional_inject_prefetch_case()) {
    case kInjectPrefetch: {
      _this->_internal_set_inject_prefetch(from._internal_inject_prefetch());
      break;
    }
    case OPTIONAL_INJECT_PREFETCH_NOT_SET: {
      break;
    }
  }
  clear_has_optional_seq_interleave_prefetch();
  switch (from.optional_seq_interleave_prefetch_case()) {
    case kSeqInterleavePrefetch: {
      _this->_internal_set_seq_interleave_prefetch(from._internal_seq_interleave_prefetch());
      break;
    }
    case OPTIONAL_SEQ_INTERLEAVE_PREFETCH_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tensorflow.data.OptimizationOptions)
}

inline void OptimizationOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.optional_apply_default_optimizations_){}
    , decltype(_impl_.optional_filter_fusion_){}
    , decltype(_impl_.optional_map_and_batch_fusion_){}
    , decltype(_impl_.optional_map_and_filter_fusion_){}
    , decltype(_impl_.optional_map_fusion_){}
    , decltype(_impl_.optional_map_parallelization_){}
    , decltype(_impl_.optional_noop_elimination_){}
    , decltype(_impl_.optional_parallel_batch_){}
    , decltype(_impl_.optional_shuffle_and_repeat_fusion_){}
    , decltype(_impl_.optional_filter_parallelization_){}
    , decltype(_impl_.optional_inject_prefetch_){}
    , decltype(_impl_.optional_seq_interleave_prefetch_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_optional_apply_default_optimizations();
  clear_has_optional_filter_fusion();
  clear_has_optional_map_and_batch_fusion();
  clear_has_optional_map_and_filter_fusion();
  clear_has_optional_map_fusion();
  clear_has_optional_map_parallelization();
  clear_has_optional_noop_elimination();
  clear_has_optional_parallel_batch();
  clear_has_optional_shuffle_and_repeat_fusion();
  clear_has_optional_filter_parallelization();
  clear_has_optional_inject_prefetch();
  clear_has_optional_seq_interleave_prefetch();
}

OptimizationOptions::~OptimizationOptions() {
  // @@protoc_insertion_point(destructor:tensorflow.data.OptimizationOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OptimizationOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_optional_apply_default_optimizations()) {
    clear_optional_apply_default_optimizations();
  }
  if (has_optional_filter_fusion()) {
    clear_optional_filter_fusion();
  }
  if (has_optional_map_and_batch_fusion()) {
    clear_optional_map_and_batch_fusion();
  }
  if (has_optional_map_and_filter_fusion()) {
    clear_optional_map_and_filter_fusion();
  }
  if (has_optional_map_fusion()) {
    clear_optional_map_fusion();
  }
  if (has_optional_map_parallelization()) {
    clear_optional_map_parallelization();
  }
  if (has_optional_noop_elimination()) {
    clear_optional_noop_elimination();
  }
  if (has_optional_parallel_batch()) {
    clear_optional_parallel_batch();
  }
  if (has_optional_shuffle_and_repeat_fusion()) {
    clear_optional_shuffle_and_repeat_fusion();
  }
  if (has_optional_filter_parallelization()) {
    clear_optional_filter_parallelization();
  }
  if (has_optional_inject_prefetch()) {
    clear_optional_inject_prefetch();
  }
  if (has_optional_seq_interleave_prefetch()) {
    clear_optional_seq_interleave_prefetch();
  }
}

void OptimizationOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OptimizationOptions::clear_optional_apply_default_optimizations() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.OptimizationOptions)
  switch (optional_apply_default_optimizations_case()) {
    case kApplyDefaultOptimizations: {
      // No need to clear
      break;
    }
    case OPTIONAL_APPLY_DEFAULT_OPTIMIZATIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = OPTIONAL_APPLY_DEFAULT_OPTIMIZATIONS_NOT_SET;
}

void OptimizationOptions::clear_optional_filter_fusion() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.OptimizationOptions)
  switch (optional_filter_fusion_case()) {
    case kFilterFusion: {
      // No need to clear
      break;
    }
    case OPTIONAL_FILTER_FUSION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = OPTIONAL_FILTER_FUSION_NOT_SET;
}

void OptimizationOptions::clear_optional_map_and_batch_fusion() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.OptimizationOptions)
  switch (optional_map_and_batch_fusion_case()) {
    case kMapAndBatchFusion: {
      // No need to clear
      break;
    }
    case OPTIONAL_MAP_AND_BATCH_FUSION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = OPTIONAL_MAP_AND_BATCH_FUSION_NOT_SET;
}

void OptimizationOptions::clear_optional_map_and_filter_fusion() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.OptimizationOptions)
  switch (optional_map_and_filter_fusion_case()) {
    case kMapAndFilterFusion: {
      // No need to clear
      break;
    }
    case OPTIONAL_MAP_AND_FILTER_FUSION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = OPTIONAL_MAP_AND_FILTER_FUSION_NOT_SET;
}

void OptimizationOptions::clear_optional_map_fusion() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.OptimizationOptions)
  switch (optional_map_fusion_case()) {
    case kMapFusion: {
      // No need to clear
      break;
    }
    case OPTIONAL_MAP_FUSION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = OPTIONAL_MAP_FUSION_NOT_SET;
}

void OptimizationOptions::clear_optional_map_parallelization() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.OptimizationOptions)
  switch (optional_map_parallelization_case()) {
    case kMapParallelization: {
      // No need to clear
      break;
    }
    case OPTIONAL_MAP_PARALLELIZATION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[5] = OPTIONAL_MAP_PARALLELIZATION_NOT_SET;
}

void OptimizationOptions::clear_optional_noop_elimination() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.OptimizationOptions)
  switch (optional_noop_elimination_case()) {
    case kNoopElimination: {
      // No need to clear
      break;
    }
    case OPTIONAL_NOOP_ELIMINATION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[6] = OPTIONAL_NOOP_ELIMINATION_NOT_SET;
}

void OptimizationOptions::clear_optional_parallel_batch() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.OptimizationOptions)
  switch (optional_parallel_batch_case()) {
    case kParallelBatch: {
      // No need to clear
      break;
    }
    case OPTIONAL_PARALLEL_BATCH_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[7] = OPTIONAL_PARALLEL_BATCH_NOT_SET;
}

void OptimizationOptions::clear_optional_shuffle_and_repeat_fusion() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.OptimizationOptions)
  switch (optional_shuffle_and_repeat_fusion_case()) {
    case kShuffleAndRepeatFusion: {
      // No need to clear
      break;
    }
    case OPTIONAL_SHUFFLE_AND_REPEAT_FUSION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[8] = OPTIONAL_SHUFFLE_AND_REPEAT_FUSION_NOT_SET;
}

void OptimizationOptions::clear_optional_filter_parallelization() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.OptimizationOptions)
  switch (optional_filter_parallelization_case()) {
    case kFilterParallelization: {
      // No need to clear
      break;
    }
    case OPTIONAL_FILTER_PARALLELIZATION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[9] = OPTIONAL_FILTER_PARALLELIZATION_NOT_SET;
}

void OptimizationOptions::clear_optional_inject_prefetch() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.OptimizationOptions)
  switch (optional_inject_prefetch_case()) {
    case kInjectPrefetch: {
      // No need to clear
      break;
    }
    case OPTIONAL_INJECT_PREFETCH_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[10] = OPTIONAL_INJECT_PREFETCH_NOT_SET;
}

void OptimizationOptions::clear_optional_seq_interleave_prefetch() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.OptimizationOptions)
  switch (optional_seq_interleave_prefetch_case()) {
    case kSeqInterleavePrefetch: {
      // No need to clear
      break;
    }
    case OPTIONAL_SEQ_INTERLEAVE_PREFETCH_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[11] = OPTIONAL_SEQ_INTERLEAVE_PREFETCH_NOT_SET;
}


void OptimizationOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.data.OptimizationOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_optional_apply_default_optimizations();
  clear_optional_filter_fusion();
  clear_optional_map_and_batch_fusion();
  clear_optional_map_and_filter_fusion();
  clear_optional_map_fusion();
  clear_optional_map_parallelization();
  clear_optional_noop_elimination();
  clear_optional_parallel_batch();
  clear_optional_shuffle_and_repeat_fusion();
  clear_optional_filter_parallelization();
  clear_optional_inject_prefetch();
  clear_optional_seq_interleave_prefetch();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OptimizationOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool apply_default_optimizations = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_apply_default_optimizations(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool filter_fusion = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _internal_set_filter_fusion(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool map_and_batch_fusion = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _internal_set_map_and_batch_fusion(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool map_and_filter_fusion = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _internal_set_map_and_filter_fusion(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool map_fusion = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _internal_set_map_fusion(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool map_parallelization = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _internal_set_map_parallelization(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool noop_elimination = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _internal_set_noop_elimination(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool parallel_batch = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _internal_set_parallel_batch(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool shuffle_and_repeat_fusion = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _internal_set_shuffle_and_repeat_fusion(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool filter_parallelization = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _internal_set_filter_parallelization(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool inject_prefetch = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _internal_set_inject_prefetch(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool seq_interleave_prefetch = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _internal_set_seq_interleave_prefetch(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OptimizationOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.data.OptimizationOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool apply_default_optimizations = 1;
  if (_internal_has_apply_default_optimizations()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_apply_default_optimizations(), target);
  }

  // bool filter_fusion = 6;
  if (_internal_has_filter_fusion()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_filter_fusion(), target);
  }

  // bool map_and_batch_fusion = 9;
  if (_internal_has_map_and_batch_fusion()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_map_and_batch_fusion(), target);
  }

  // bool map_and_filter_fusion = 10;
  if (_internal_has_map_and_filter_fusion()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_map_and_filter_fusion(), target);
  }

  // bool map_fusion = 11;
  if (_internal_has_map_fusion()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_map_fusion(), target);
  }

  // bool map_parallelization = 12;
  if (_internal_has_map_parallelization()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_map_parallelization(), target);
  }

  // bool noop_elimination = 14;
  if (_internal_has_noop_elimination()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_noop_elimination(), target);
  }

  // bool parallel_batch = 15;
  if (_internal_has_parallel_batch()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_parallel_batch(), target);
  }

  // bool shuffle_and_repeat_fusion = 17;
  if (_internal_has_shuffle_and_repeat_fusion()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_shuffle_and_repeat_fusion(), target);
  }

  // bool filter_parallelization = 18;
  if (_internal_has_filter_parallelization()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_filter_parallelization(), target);
  }

  // bool inject_prefetch = 19;
  if (_internal_has_inject_prefetch()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_inject_prefetch(), target);
  }

  // bool seq_interleave_prefetch = 21;
  if (_internal_has_seq_interleave_prefetch()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_seq_interleave_prefetch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.data.OptimizationOptions)
  return target;
}

size_t OptimizationOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.data.OptimizationOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (optional_apply_default_optimizations_case()) {
    // bool apply_default_optimizations = 1;
    case kApplyDefaultOptimizations: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_APPLY_DEFAULT_OPTIMIZATIONS_NOT_SET: {
      break;
    }
  }
  switch (optional_filter_fusion_case()) {
    // bool filter_fusion = 6;
    case kFilterFusion: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_FILTER_FUSION_NOT_SET: {
      break;
    }
  }
  switch (optional_map_and_batch_fusion_case()) {
    // bool map_and_batch_fusion = 9;
    case kMapAndBatchFusion: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_MAP_AND_BATCH_FUSION_NOT_SET: {
      break;
    }
  }
  switch (optional_map_and_filter_fusion_case()) {
    // bool map_and_filter_fusion = 10;
    case kMapAndFilterFusion: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_MAP_AND_FILTER_FUSION_NOT_SET: {
      break;
    }
  }
  switch (optional_map_fusion_case()) {
    // bool map_fusion = 11;
    case kMapFusion: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_MAP_FUSION_NOT_SET: {
      break;
    }
  }
  switch (optional_map_parallelization_case()) {
    // bool map_parallelization = 12;
    case kMapParallelization: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_MAP_PARALLELIZATION_NOT_SET: {
      break;
    }
  }
  switch (optional_noop_elimination_case()) {
    // bool noop_elimination = 14;
    case kNoopElimination: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_NOOP_ELIMINATION_NOT_SET: {
      break;
    }
  }
  switch (optional_parallel_batch_case()) {
    // bool parallel_batch = 15;
    case kParallelBatch: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_PARALLEL_BATCH_NOT_SET: {
      break;
    }
  }
  switch (optional_shuffle_and_repeat_fusion_case()) {
    // bool shuffle_and_repeat_fusion = 17;
    case kShuffleAndRepeatFusion: {
      total_size += 2 + 1;
      break;
    }
    case OPTIONAL_SHUFFLE_AND_REPEAT_FUSION_NOT_SET: {
      break;
    }
  }
  switch (optional_filter_parallelization_case()) {
    // bool filter_parallelization = 18;
    case kFilterParallelization: {
      total_size += 2 + 1;
      break;
    }
    case OPTIONAL_FILTER_PARALLELIZATION_NOT_SET: {
      break;
    }
  }
  switch (optional_inject_prefetch_case()) {
    // bool inject_prefetch = 19;
    case kInjectPrefetch: {
      total_size += 2 + 1;
      break;
    }
    case OPTIONAL_INJECT_PREFETCH_NOT_SET: {
      break;
    }
  }
  switch (optional_seq_interleave_prefetch_case()) {
    // bool seq_interleave_prefetch = 21;
    case kSeqInterleavePrefetch: {
      total_size += 2 + 1;
      break;
    }
    case OPTIONAL_SEQ_INTERLEAVE_PREFETCH_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OptimizationOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OptimizationOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OptimizationOptions::GetClassData() const { return &_class_data_; }


void OptimizationOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OptimizationOptions*>(&to_msg);
  auto& from = static_cast<const OptimizationOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.data.OptimizationOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.optional_apply_default_optimizations_case()) {
    case kApplyDefaultOptimizations: {
      _this->_internal_set_apply_default_optimizations(from._internal_apply_default_optimizations());
      break;
    }
    case OPTIONAL_APPLY_DEFAULT_OPTIMIZATIONS_NOT_SET: {
      break;
    }
  }
  switch (from.optional_filter_fusion_case()) {
    case kFilterFusion: {
      _this->_internal_set_filter_fusion(from._internal_filter_fusion());
      break;
    }
    case OPTIONAL_FILTER_FUSION_NOT_SET: {
      break;
    }
  }
  switch (from.optional_map_and_batch_fusion_case()) {
    case kMapAndBatchFusion: {
      _this->_internal_set_map_and_batch_fusion(from._internal_map_and_batch_fusion());
      break;
    }
    case OPTIONAL_MAP_AND_BATCH_FUSION_NOT_SET: {
      break;
    }
  }
  switch (from.optional_map_and_filter_fusion_case()) {
    case kMapAndFilterFusion: {
      _this->_internal_set_map_and_filter_fusion(from._internal_map_and_filter_fusion());
      break;
    }
    case OPTIONAL_MAP_AND_FILTER_FUSION_NOT_SET: {
      break;
    }
  }
  switch (from.optional_map_fusion_case()) {
    case kMapFusion: {
      _this->_internal_set_map_fusion(from._internal_map_fusion());
      break;
    }
    case OPTIONAL_MAP_FUSION_NOT_SET: {
      break;
    }
  }
  switch (from.optional_map_parallelization_case()) {
    case kMapParallelization: {
      _this->_internal_set_map_parallelization(from._internal_map_parallelization());
      break;
    }
    case OPTIONAL_MAP_PARALLELIZATION_NOT_SET: {
      break;
    }
  }
  switch (from.optional_noop_elimination_case()) {
    case kNoopElimination: {
      _this->_internal_set_noop_elimination(from._internal_noop_elimination());
      break;
    }
    case OPTIONAL_NOOP_ELIMINATION_NOT_SET: {
      break;
    }
  }
  switch (from.optional_parallel_batch_case()) {
    case kParallelBatch: {
      _this->_internal_set_parallel_batch(from._internal_parallel_batch());
      break;
    }
    case OPTIONAL_PARALLEL_BATCH_NOT_SET: {
      break;
    }
  }
  switch (from.optional_shuffle_and_repeat_fusion_case()) {
    case kShuffleAndRepeatFusion: {
      _this->_internal_set_shuffle_and_repeat_fusion(from._internal_shuffle_and_repeat_fusion());
      break;
    }
    case OPTIONAL_SHUFFLE_AND_REPEAT_FUSION_NOT_SET: {
      break;
    }
  }
  switch (from.optional_filter_parallelization_case()) {
    case kFilterParallelization: {
      _this->_internal_set_filter_parallelization(from._internal_filter_parallelization());
      break;
    }
    case OPTIONAL_FILTER_PARALLELIZATION_NOT_SET: {
      break;
    }
  }
  switch (from.optional_inject_prefetch_case()) {
    case kInjectPrefetch: {
      _this->_internal_set_inject_prefetch(from._internal_inject_prefetch());
      break;
    }
    case OPTIONAL_INJECT_PREFETCH_NOT_SET: {
      break;
    }
  }
  switch (from.optional_seq_interleave_prefetch_case()) {
    case kSeqInterleavePrefetch: {
      _this->_internal_set_seq_interleave_prefetch(from._internal_seq_interleave_prefetch());
      break;
    }
    case OPTIONAL_SEQ_INTERLEAVE_PREFETCH_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OptimizationOptions::CopyFrom(const OptimizationOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.data.OptimizationOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OptimizationOptions::IsInitialized() const {
  return true;
}

void OptimizationOptions::InternalSwap(OptimizationOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.optional_apply_default_optimizations_, other->_impl_.optional_apply_default_optimizations_);
  swap(_impl_.optional_filter_fusion_, other->_impl_.optional_filter_fusion_);
  swap(_impl_.optional_map_and_batch_fusion_, other->_impl_.optional_map_and_batch_fusion_);
  swap(_impl_.optional_map_and_filter_fusion_, other->_impl_.optional_map_and_filter_fusion_);
  swap(_impl_.optional_map_fusion_, other->_impl_.optional_map_fusion_);
  swap(_impl_.optional_map_parallelization_, other->_impl_.optional_map_parallelization_);
  swap(_impl_.optional_noop_elimination_, other->_impl_.optional_noop_elimination_);
  swap(_impl_.optional_parallel_batch_, other->_impl_.optional_parallel_batch_);
  swap(_impl_.optional_shuffle_and_repeat_fusion_, other->_impl_.optional_shuffle_and_repeat_fusion_);
  swap(_impl_.optional_filter_parallelization_, other->_impl_.optional_filter_parallelization_);
  swap(_impl_.optional_inject_prefetch_, other->_impl_.optional_inject_prefetch_);
  swap(_impl_.optional_seq_interleave_prefetch_, other->_impl_.optional_seq_interleave_prefetch_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
  swap(_impl_._oneof_case_[5], other->_impl_._oneof_case_[5]);
  swap(_impl_._oneof_case_[6], other->_impl_._oneof_case_[6]);
  swap(_impl_._oneof_case_[7], other->_impl_._oneof_case_[7]);
  swap(_impl_._oneof_case_[8], other->_impl_._oneof_case_[8]);
  swap(_impl_._oneof_case_[9], other->_impl_._oneof_case_[9]);
  swap(_impl_._oneof_case_[10], other->_impl_._oneof_case_[10]);
  swap(_impl_._oneof_case_[11], other->_impl_._oneof_case_[11]);
}

::PROTOBUF_NAMESPACE_ID::Metadata OptimizationOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto[3]);
}

// ===================================================================

class ThreadingOptions::_Internal {
 public:
};

ThreadingOptions::ThreadingOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.data.ThreadingOptions)
}
ThreadingOptions::ThreadingOptions(const ThreadingOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ThreadingOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.optional_max_intra_op_parallelism_){}
    , decltype(_impl_.optional_private_threadpool_size_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_optional_max_intra_op_parallelism();
  switch (from.optional_max_intra_op_parallelism_case()) {
    case kMaxIntraOpParallelism: {
      _this->_internal_set_max_intra_op_parallelism(from._internal_max_intra_op_parallelism());
      break;
    }
    case OPTIONAL_MAX_INTRA_OP_PARALLELISM_NOT_SET: {
      break;
    }
  }
  clear_has_optional_private_threadpool_size();
  switch (from.optional_private_threadpool_size_case()) {
    case kPrivateThreadpoolSize: {
      _this->_internal_set_private_threadpool_size(from._internal_private_threadpool_size());
      break;
    }
    case OPTIONAL_PRIVATE_THREADPOOL_SIZE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tensorflow.data.ThreadingOptions)
}

inline void ThreadingOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.optional_max_intra_op_parallelism_){}
    , decltype(_impl_.optional_private_threadpool_size_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_optional_max_intra_op_parallelism();
  clear_has_optional_private_threadpool_size();
}

ThreadingOptions::~ThreadingOptions() {
  // @@protoc_insertion_point(destructor:tensorflow.data.ThreadingOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreadingOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_optional_max_intra_op_parallelism()) {
    clear_optional_max_intra_op_parallelism();
  }
  if (has_optional_private_threadpool_size()) {
    clear_optional_private_threadpool_size();
  }
}

void ThreadingOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreadingOptions::clear_optional_max_intra_op_parallelism() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.ThreadingOptions)
  switch (optional_max_intra_op_parallelism_case()) {
    case kMaxIntraOpParallelism: {
      // No need to clear
      break;
    }
    case OPTIONAL_MAX_INTRA_OP_PARALLELISM_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = OPTIONAL_MAX_INTRA_OP_PARALLELISM_NOT_SET;
}

void ThreadingOptions::clear_optional_private_threadpool_size() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.ThreadingOptions)
  switch (optional_private_threadpool_size_case()) {
    case kPrivateThreadpoolSize: {
      // No need to clear
      break;
    }
    case OPTIONAL_PRIVATE_THREADPOOL_SIZE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = OPTIONAL_PRIVATE_THREADPOOL_SIZE_NOT_SET;
}


void ThreadingOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.data.ThreadingOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_optional_max_intra_op_parallelism();
  clear_optional_private_threadpool_size();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ThreadingOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 max_intra_op_parallelism = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_max_intra_op_parallelism(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 private_threadpool_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_private_threadpool_size(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreadingOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.data.ThreadingOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 max_intra_op_parallelism = 1;
  if (_internal_has_max_intra_op_parallelism()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_max_intra_op_parallelism(), target);
  }

  // int32 private_threadpool_size = 2;
  if (_internal_has_private_threadpool_size()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_private_threadpool_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.data.ThreadingOptions)
  return target;
}

size_t ThreadingOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.data.ThreadingOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (optional_max_intra_op_parallelism_case()) {
    // int32 max_intra_op_parallelism = 1;
    case kMaxIntraOpParallelism: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_intra_op_parallelism());
      break;
    }
    case OPTIONAL_MAX_INTRA_OP_PARALLELISM_NOT_SET: {
      break;
    }
  }
  switch (optional_private_threadpool_size_case()) {
    // int32 private_threadpool_size = 2;
    case kPrivateThreadpoolSize: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_private_threadpool_size());
      break;
    }
    case OPTIONAL_PRIVATE_THREADPOOL_SIZE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ThreadingOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ThreadingOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ThreadingOptions::GetClassData() const { return &_class_data_; }


void ThreadingOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ThreadingOptions*>(&to_msg);
  auto& from = static_cast<const ThreadingOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.data.ThreadingOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.optional_max_intra_op_parallelism_case()) {
    case kMaxIntraOpParallelism: {
      _this->_internal_set_max_intra_op_parallelism(from._internal_max_intra_op_parallelism());
      break;
    }
    case OPTIONAL_MAX_INTRA_OP_PARALLELISM_NOT_SET: {
      break;
    }
  }
  switch (from.optional_private_threadpool_size_case()) {
    case kPrivateThreadpoolSize: {
      _this->_internal_set_private_threadpool_size(from._internal_private_threadpool_size());
      break;
    }
    case OPTIONAL_PRIVATE_THREADPOOL_SIZE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ThreadingOptions::CopyFrom(const ThreadingOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.data.ThreadingOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreadingOptions::IsInitialized() const {
  return true;
}

void ThreadingOptions::InternalSwap(ThreadingOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.optional_max_intra_op_parallelism_, other->_impl_.optional_max_intra_op_parallelism_);
  swap(_impl_.optional_private_threadpool_size_, other->_impl_.optional_private_threadpool_size_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ThreadingOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto[4]);
}

// ===================================================================

class Options::_Internal {
 public:
  static const ::tensorflow::data::AutotuneOptions& autotune_options(const Options* msg);
  static const ::tensorflow::data::DistributeOptions& distribute_options(const Options* msg);
  static const ::tensorflow::data::OptimizationOptions& optimization_options(const Options* msg);
  static const ::tensorflow::data::ThreadingOptions& threading_options(const Options* msg);
};

const ::tensorflow::data::AutotuneOptions&
Options::_Internal::autotune_options(const Options* msg) {
  return *msg->_impl_.autotune_options_;
}
const ::tensorflow::data::DistributeOptions&
Options::_Internal::distribute_options(const Options* msg) {
  return *msg->_impl_.distribute_options_;
}
const ::tensorflow::data::OptimizationOptions&
Options::_Internal::optimization_options(const Options* msg) {
  return *msg->_impl_.optimization_options_;
}
const ::tensorflow::data::ThreadingOptions&
Options::_Internal::threading_options(const Options* msg) {
  return *msg->_impl_.threading_options_;
}
Options::Options(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.data.Options)
}
Options::Options(const Options& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Options* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.framework_type_){from._impl_.framework_type_}
    , decltype(_impl_.distribute_options_){nullptr}
    , decltype(_impl_.optimization_options_){nullptr}
    , decltype(_impl_.threading_options_){nullptr}
    , decltype(_impl_.autotune_options_){nullptr}
    , decltype(_impl_.optional_dataset_name_){}
    , decltype(_impl_.optional_deterministic_){}
    , decltype(_impl_.optional_slack_){}
    , decltype(_impl_.optional_external_state_policy_){}
    , decltype(_impl_.optional_symbolic_checkpoint_){}
    , decltype(_impl_.optional_warm_start_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_distribute_options()) {
    _this->_impl_.distribute_options_ = new ::tensorflow::data::DistributeOptions(*from._impl_.distribute_options_);
  }
  if (from._internal_has_optimization_options()) {
    _this->_impl_.optimization_options_ = new ::tensorflow::data::OptimizationOptions(*from._impl_.optimization_options_);
  }
  if (from._internal_has_threading_options()) {
    _this->_impl_.threading_options_ = new ::tensorflow::data::ThreadingOptions(*from._impl_.threading_options_);
  }
  if (from._internal_has_autotune_options()) {
    _this->_impl_.autotune_options_ = new ::tensorflow::data::AutotuneOptions(*from._impl_.autotune_options_);
  }
  clear_has_optional_dataset_name();
  switch (from.optional_dataset_name_case()) {
    case kDatasetName: {
      _this->_internal_set_dataset_name(from._internal_dataset_name());
      break;
    }
    case OPTIONAL_DATASET_NAME_NOT_SET: {
      break;
    }
  }
  clear_has_optional_deterministic();
  switch (from.optional_deterministic_case()) {
    case kDeterministic: {
      _this->_internal_set_deterministic(from._internal_deterministic());
      break;
    }
    case OPTIONAL_DETERMINISTIC_NOT_SET: {
      break;
    }
  }
  clear_has_optional_slack();
  switch (from.optional_slack_case()) {
    case kSlack: {
      _this->_internal_set_slack(from._internal_slack());
      break;
    }
    case OPTIONAL_SLACK_NOT_SET: {
      break;
    }
  }
  clear_has_optional_external_state_policy();
  switch (from.optional_external_state_policy_case()) {
    case kExternalStatePolicy: {
      _this->_internal_set_external_state_policy(from._internal_external_state_policy());
      break;
    }
    case OPTIONAL_EXTERNAL_STATE_POLICY_NOT_SET: {
      break;
    }
  }
  clear_has_optional_symbolic_checkpoint();
  switch (from.optional_symbolic_checkpoint_case()) {
    case kSymbolicCheckpoint: {
      _this->_internal_set_symbolic_checkpoint(from._internal_symbolic_checkpoint());
      break;
    }
    case OPTIONAL_SYMBOLIC_CHECKPOINT_NOT_SET: {
      break;
    }
  }
  clear_has_optional_warm_start();
  switch (from.optional_warm_start_case()) {
    case kWarmStart: {
      _this->_internal_set_warm_start(from._internal_warm_start());
      break;
    }
    case OPTIONAL_WARM_START_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tensorflow.data.Options)
}

inline void Options::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.framework_type_){arena}
    , decltype(_impl_.distribute_options_){nullptr}
    , decltype(_impl_.optimization_options_){nullptr}
    , decltype(_impl_.threading_options_){nullptr}
    , decltype(_impl_.autotune_options_){nullptr}
    , decltype(_impl_.optional_dataset_name_){}
    , decltype(_impl_.optional_deterministic_){}
    , decltype(_impl_.optional_slack_){}
    , decltype(_impl_.optional_external_state_policy_){}
    , decltype(_impl_.optional_symbolic_checkpoint_){}
    , decltype(_impl_.optional_warm_start_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_optional_dataset_name();
  clear_has_optional_deterministic();
  clear_has_optional_slack();
  clear_has_optional_external_state_policy();
  clear_has_optional_symbolic_checkpoint();
  clear_has_optional_warm_start();
}

Options::~Options() {
  // @@protoc_insertion_point(destructor:tensorflow.data.Options)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Options::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.framework_type_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.distribute_options_;
  if (this != internal_default_instance()) delete _impl_.optimization_options_;
  if (this != internal_default_instance()) delete _impl_.threading_options_;
  if (this != internal_default_instance()) delete _impl_.autotune_options_;
  if (has_optional_dataset_name()) {
    clear_optional_dataset_name();
  }
  if (has_optional_deterministic()) {
    clear_optional_deterministic();
  }
  if (has_optional_slack()) {
    clear_optional_slack();
  }
  if (has_optional_external_state_policy()) {
    clear_optional_external_state_policy();
  }
  if (has_optional_symbolic_checkpoint()) {
    clear_optional_symbolic_checkpoint();
  }
  if (has_optional_warm_start()) {
    clear_optional_warm_start();
  }
}

void Options::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Options::clear_optional_dataset_name() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.Options)
  switch (optional_dataset_name_case()) {
    case kDatasetName: {
      _impl_.optional_dataset_name_.dataset_name_.Destroy();
      break;
    }
    case OPTIONAL_DATASET_NAME_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = OPTIONAL_DATASET_NAME_NOT_SET;
}

void Options::clear_optional_deterministic() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.Options)
  switch (optional_deterministic_case()) {
    case kDeterministic: {
      // No need to clear
      break;
    }
    case OPTIONAL_DETERMINISTIC_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = OPTIONAL_DETERMINISTIC_NOT_SET;
}

void Options::clear_optional_slack() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.Options)
  switch (optional_slack_case()) {
    case kSlack: {
      // No need to clear
      break;
    }
    case OPTIONAL_SLACK_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = OPTIONAL_SLACK_NOT_SET;
}

void Options::clear_optional_external_state_policy() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.Options)
  switch (optional_external_state_policy_case()) {
    case kExternalStatePolicy: {
      // No need to clear
      break;
    }
    case OPTIONAL_EXTERNAL_STATE_POLICY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = OPTIONAL_EXTERNAL_STATE_POLICY_NOT_SET;
}

void Options::clear_optional_symbolic_checkpoint() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.Options)
  switch (optional_symbolic_checkpoint_case()) {
    case kSymbolicCheckpoint: {
      // No need to clear
      break;
    }
    case OPTIONAL_SYMBOLIC_CHECKPOINT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = OPTIONAL_SYMBOLIC_CHECKPOINT_NOT_SET;
}

void Options::clear_optional_warm_start() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.data.Options)
  switch (optional_warm_start_case()) {
    case kWarmStart: {
      // No need to clear
      break;
    }
    case OPTIONAL_WARM_START_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[5] = OPTIONAL_WARM_START_NOT_SET;
}


void Options::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.data.Options)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.framework_type_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.distribute_options_ != nullptr) {
    delete _impl_.distribute_options_;
  }
  _impl_.distribute_options_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.optimization_options_ != nullptr) {
    delete _impl_.optimization_options_;
  }
  _impl_.optimization_options_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.threading_options_ != nullptr) {
    delete _impl_.threading_options_;
  }
  _impl_.threading_options_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.autotune_options_ != nullptr) {
    delete _impl_.autotune_options_;
  }
  _impl_.autotune_options_ = nullptr;
  clear_optional_dataset_name();
  clear_optional_deterministic();
  clear_optional_slack();
  clear_optional_external_state_policy();
  clear_optional_symbolic_checkpoint();
  clear_optional_warm_start();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Options::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool deterministic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_deterministic(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.data.DistributeOptions distribute_options = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_distribute_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.data.OptimizationOptions optimization_options = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_optimization_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool slack = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_slack(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.data.ThreadingOptions threading_options = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_threading_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.data.ExternalStatePolicy external_state_policy = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_external_state_policy(static_cast<::tensorflow::data::ExternalStatePolicy>(val));
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.data.AutotuneOptions autotune_options = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_autotune_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool symbolic_checkpoint = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _internal_set_symbolic_checkpoint(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool warm_start = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _internal_set_warm_start(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string dataset_name = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_dataset_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tensorflow.data.Options.dataset_name"));
        } else
          goto handle_unusual;
        continue;
      // repeated string framework_type = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_framework_type();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "tensorflow.data.Options.framework_type"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Options::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.data.Options)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool deterministic = 1;
  if (_internal_has_deterministic()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_deterministic(), target);
  }

  // .tensorflow.data.DistributeOptions distribute_options = 2;
  if (this->_internal_has_distribute_options()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::distribute_options(this),
        _Internal::distribute_options(this).GetCachedSize(), target, stream);
  }

  // .tensorflow.data.OptimizationOptions optimization_options = 3;
  if (this->_internal_has_optimization_options()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::optimization_options(this),
        _Internal::optimization_options(this).GetCachedSize(), target, stream);
  }

  // bool slack = 4;
  if (_internal_has_slack()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_slack(), target);
  }

  // .tensorflow.data.ThreadingOptions threading_options = 5;
  if (this->_internal_has_threading_options()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::threading_options(this),
        _Internal::threading_options(this).GetCachedSize(), target, stream);
  }

  // .tensorflow.data.ExternalStatePolicy external_state_policy = 6;
  if (_internal_has_external_state_policy()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_external_state_policy(), target);
  }

  // .tensorflow.data.AutotuneOptions autotune_options = 7;
  if (this->_internal_has_autotune_options()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::autotune_options(this),
        _Internal::autotune_options(this).GetCachedSize(), target, stream);
  }

  // bool symbolic_checkpoint = 8;
  if (_internal_has_symbolic_checkpoint()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_symbolic_checkpoint(), target);
  }

  // bool warm_start = 9;
  if (_internal_has_warm_start()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_warm_start(), target);
  }

  // string dataset_name = 10;
  if (_internal_has_dataset_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_dataset_name().data(), static_cast<int>(this->_internal_dataset_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tensorflow.data.Options.dataset_name");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_dataset_name(), target);
  }

  // repeated string framework_type = 11;
  for (int i = 0, n = this->_internal_framework_type_size(); i < n; i++) {
    const auto& s = this->_internal_framework_type(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tensorflow.data.Options.framework_type");
    target = stream->WriteString(11, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.data.Options)
  return target;
}

size_t Options::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.data.Options)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string framework_type = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.framework_type_.size());
  for (int i = 0, n = _impl_.framework_type_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.framework_type_.Get(i));
  }

  // .tensorflow.data.DistributeOptions distribute_options = 2;
  if (this->_internal_has_distribute_options()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.distribute_options_);
  }

  // .tensorflow.data.OptimizationOptions optimization_options = 3;
  if (this->_internal_has_optimization_options()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.optimization_options_);
  }

  // .tensorflow.data.ThreadingOptions threading_options = 5;
  if (this->_internal_has_threading_options()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.threading_options_);
  }

  // .tensorflow.data.AutotuneOptions autotune_options = 7;
  if (this->_internal_has_autotune_options()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.autotune_options_);
  }

  switch (optional_dataset_name_case()) {
    // string dataset_name = 10;
    case kDatasetName: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dataset_name());
      break;
    }
    case OPTIONAL_DATASET_NAME_NOT_SET: {
      break;
    }
  }
  switch (optional_deterministic_case()) {
    // bool deterministic = 1;
    case kDeterministic: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_DETERMINISTIC_NOT_SET: {
      break;
    }
  }
  switch (optional_slack_case()) {
    // bool slack = 4;
    case kSlack: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_SLACK_NOT_SET: {
      break;
    }
  }
  switch (optional_external_state_policy_case()) {
    // .tensorflow.data.ExternalStatePolicy external_state_policy = 6;
    case kExternalStatePolicy: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_external_state_policy());
      break;
    }
    case OPTIONAL_EXTERNAL_STATE_POLICY_NOT_SET: {
      break;
    }
  }
  switch (optional_symbolic_checkpoint_case()) {
    // bool symbolic_checkpoint = 8;
    case kSymbolicCheckpoint: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_SYMBOLIC_CHECKPOINT_NOT_SET: {
      break;
    }
  }
  switch (optional_warm_start_case()) {
    // bool warm_start = 9;
    case kWarmStart: {
      total_size += 1 + 1;
      break;
    }
    case OPTIONAL_WARM_START_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Options::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Options::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Options::GetClassData() const { return &_class_data_; }


void Options::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Options*>(&to_msg);
  auto& from = static_cast<const Options&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.data.Options)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.framework_type_.MergeFrom(from._impl_.framework_type_);
  if (from._internal_has_distribute_options()) {
    _this->_internal_mutable_distribute_options()->::tensorflow::data::DistributeOptions::MergeFrom(
        from._internal_distribute_options());
  }
  if (from._internal_has_optimization_options()) {
    _this->_internal_mutable_optimization_options()->::tensorflow::data::OptimizationOptions::MergeFrom(
        from._internal_optimization_options());
  }
  if (from._internal_has_threading_options()) {
    _this->_internal_mutable_threading_options()->::tensorflow::data::ThreadingOptions::MergeFrom(
        from._internal_threading_options());
  }
  if (from._internal_has_autotune_options()) {
    _this->_internal_mutable_autotune_options()->::tensorflow::data::AutotuneOptions::MergeFrom(
        from._internal_autotune_options());
  }
  switch (from.optional_dataset_name_case()) {
    case kDatasetName: {
      _this->_internal_set_dataset_name(from._internal_dataset_name());
      break;
    }
    case OPTIONAL_DATASET_NAME_NOT_SET: {
      break;
    }
  }
  switch (from.optional_deterministic_case()) {
    case kDeterministic: {
      _this->_internal_set_deterministic(from._internal_deterministic());
      break;
    }
    case OPTIONAL_DETERMINISTIC_NOT_SET: {
      break;
    }
  }
  switch (from.optional_slack_case()) {
    case kSlack: {
      _this->_internal_set_slack(from._internal_slack());
      break;
    }
    case OPTIONAL_SLACK_NOT_SET: {
      break;
    }
  }
  switch (from.optional_external_state_policy_case()) {
    case kExternalStatePolicy: {
      _this->_internal_set_external_state_policy(from._internal_external_state_policy());
      break;
    }
    case OPTIONAL_EXTERNAL_STATE_POLICY_NOT_SET: {
      break;
    }
  }
  switch (from.optional_symbolic_checkpoint_case()) {
    case kSymbolicCheckpoint: {
      _this->_internal_set_symbolic_checkpoint(from._internal_symbolic_checkpoint());
      break;
    }
    case OPTIONAL_SYMBOLIC_CHECKPOINT_NOT_SET: {
      break;
    }
  }
  switch (from.optional_warm_start_case()) {
    case kWarmStart: {
      _this->_internal_set_warm_start(from._internal_warm_start());
      break;
    }
    case OPTIONAL_WARM_START_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Options::CopyFrom(const Options& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.data.Options)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Options::IsInitialized() const {
  return true;
}

void Options::InternalSwap(Options* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.framework_type_.InternalSwap(&other->_impl_.framework_type_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Options, _impl_.autotune_options_)
      + sizeof(Options::_impl_.autotune_options_)
      - PROTOBUF_FIELD_OFFSET(Options, _impl_.distribute_options_)>(
          reinterpret_cast<char*>(&_impl_.distribute_options_),
          reinterpret_cast<char*>(&other->_impl_.distribute_options_));
  swap(_impl_.optional_dataset_name_, other->_impl_.optional_dataset_name_);
  swap(_impl_.optional_deterministic_, other->_impl_.optional_deterministic_);
  swap(_impl_.optional_slack_, other->_impl_.optional_slack_);
  swap(_impl_.optional_external_state_policy_, other->_impl_.optional_external_state_policy_);
  swap(_impl_.optional_symbolic_checkpoint_, other->_impl_.optional_symbolic_checkpoint_);
  swap(_impl_.optional_warm_start_, other->_impl_.optional_warm_start_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
  swap(_impl_._oneof_case_[5], other->_impl_._oneof_case_[5]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Options::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto[5]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace data
}  // namespace tensorflow
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::tensorflow::data::AutotuneOptions*
Arena::CreateMaybeMessage< ::tensorflow::data::AutotuneOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::data::AutotuneOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::data::CardinalityOptions*
Arena::CreateMaybeMessage< ::tensorflow::data::CardinalityOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::data::CardinalityOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::data::DistributeOptions*
Arena::CreateMaybeMessage< ::tensorflow::data::DistributeOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::data::DistributeOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::data::OptimizationOptions*
Arena::CreateMaybeMessage< ::tensorflow::data::OptimizationOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::data::OptimizationOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::data::ThreadingOptions*
Arena::CreateMaybeMessage< ::tensorflow::data::ThreadingOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::data::ThreadingOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::data::Options*
Arena::CreateMaybeMessage< ::tensorflow::data::Options >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::data::Options >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
