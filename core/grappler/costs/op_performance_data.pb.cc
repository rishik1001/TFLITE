// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/grappler/costs/op_performance_data.proto

#include "tensorflow/core/grappler/costs/op_performance_data.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace tensorflow {
PROTOBUF_CONSTEXPR SessionInfo::SessionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.intra_op_parallelism_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SessionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SessionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SessionInfoDefaultTypeInternal() {}
  union {
    SessionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SessionInfoDefaultTypeInternal _SessionInfo_default_instance_;
PROTOBUF_CONSTEXPR OpInfo_AttrEntry_DoNotUse::OpInfo_AttrEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct OpInfo_AttrEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpInfo_AttrEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpInfo_AttrEntry_DoNotUseDefaultTypeInternal() {}
  union {
    OpInfo_AttrEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpInfo_AttrEntry_DoNotUseDefaultTypeInternal _OpInfo_AttrEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR OpInfo_TensorProperties::OpInfo_TensorProperties(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shape_)*/nullptr
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_.dtype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OpInfo_TensorPropertiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpInfo_TensorPropertiesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpInfo_TensorPropertiesDefaultTypeInternal() {}
  union {
    OpInfo_TensorProperties _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpInfo_TensorPropertiesDefaultTypeInternal _OpInfo_TensorProperties_default_instance_;
PROTOBUF_CONSTEXPR OpInfo::OpInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.attr_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.inputs_)*/{}
  , /*decltype(_impl_.outputs_)*/{}
  , /*decltype(_impl_.op_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_)*/nullptr
  , /*decltype(_impl_.session_info_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OpInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpInfoDefaultTypeInternal() {}
  union {
    OpInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpInfoDefaultTypeInternal _OpInfo_default_instance_;
PROTOBUF_CONSTEXPR NormalDistribution::NormalDistribution(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mu_)*/0
  , /*decltype(_impl_.sigma_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NormalDistributionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NormalDistributionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NormalDistributionDefaultTypeInternal() {}
  union {
    NormalDistribution _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NormalDistributionDefaultTypeInternal _NormalDistribution_default_instance_;
PROTOBUF_CONSTEXPR LogNormalDistribution::LogNormalDistribution(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mu_)*/0
  , /*decltype(_impl_.sigma_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LogNormalDistributionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogNormalDistributionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogNormalDistributionDefaultTypeInternal() {}
  union {
    LogNormalDistribution _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogNormalDistributionDefaultTypeInternal _LogNormalDistribution_default_instance_;
PROTOBUF_CONSTEXPR OpPerformance_OpMemory::OpPerformance_OpMemory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.output_memory_)*/{}
  , /*decltype(_impl_._output_memory_cached_byte_size_)*/{0}
  , /*decltype(_impl_.temp_memory_)*/int64_t{0}
  , /*decltype(_impl_.device_temp_memory_)*/int64_t{0}
  , /*decltype(_impl_.persistent_memory_)*/int64_t{0}
  , /*decltype(_impl_.device_persistent_memory_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OpPerformance_OpMemoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpPerformance_OpMemoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpPerformance_OpMemoryDefaultTypeInternal() {}
  union {
    OpPerformance_OpMemory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpPerformance_OpMemoryDefaultTypeInternal _OpPerformance_OpMemory_default_instance_;
PROTOBUF_CONSTEXPR OpPerformance::OpPerformance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.node_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.op_)*/nullptr
  , /*decltype(_impl_.op_memory_)*/nullptr
  , /*decltype(_impl_.session_info_)*/nullptr
  , /*decltype(_impl_.temporary_memory_size_)*/int64_t{0}
  , /*decltype(_impl_.compute_cost_)*/int64_t{0}
  , /*decltype(_impl_.compute_efficiency_)*/0
  , /*decltype(_impl_.compute_time_)*/int64_t{0}
  , /*decltype(_impl_.memory_time_)*/int64_t{0}
  , /*decltype(_impl_.memory_efficiency_)*/0
  , /*decltype(_impl_.execution_time_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct OpPerformanceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpPerformanceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpPerformanceDefaultTypeInternal() {}
  union {
    OpPerformance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpPerformanceDefaultTypeInternal _OpPerformance_default_instance_;
PROTOBUF_CONSTEXPR OpPerformanceList::OpPerformanceList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.op_performance_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OpPerformanceListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpPerformanceListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpPerformanceListDefaultTypeInternal() {}
  union {
    OpPerformanceList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpPerformanceListDefaultTypeInternal _OpPerformanceList_default_instance_;
}  // namespace tensorflow
static ::_pb::Metadata file_level_metadata_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto[9];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto = nullptr;

const uint32_t TableStruct_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::SessionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tensorflow::SessionInfo, _impl_.intra_op_parallelism_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo_AttrEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo_AttrEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo_AttrEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo_AttrEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo_TensorProperties, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo_TensorProperties, _impl_.dtype_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo_TensorProperties, _impl_.shape_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo_TensorProperties, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo, _impl_.op_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo, _impl_.attr_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo, _impl_.inputs_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo, _impl_.outputs_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo, _impl_.device_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpInfo, _impl_.session_info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::NormalDistribution, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tensorflow::NormalDistribution, _impl_.mu_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::NormalDistribution, _impl_.sigma_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::LogNormalDistribution, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tensorflow::LogNormalDistribution, _impl_.mu_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::LogNormalDistribution, _impl_.sigma_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance_OpMemory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance_OpMemory, _impl_.output_memory_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance_OpMemory, _impl_.temp_memory_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance_OpMemory, _impl_.persistent_memory_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance_OpMemory, _impl_.device_temp_memory_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance_OpMemory, _impl_.device_persistent_memory_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _impl_.op_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _impl_.session_info_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _impl_.node_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _impl_.temporary_memory_size_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _impl_.compute_cost_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _impl_.compute_time_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _impl_.memory_time_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _impl_.compute_efficiency_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _impl_.memory_efficiency_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _impl_.op_memory_),
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformance, _impl_.execution_time_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformanceList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::tensorflow::OpPerformanceList, _impl_.op_performance_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::tensorflow::SessionInfo)},
  { 7, 15, -1, sizeof(::tensorflow::OpInfo_AttrEntry_DoNotUse)},
  { 17, -1, -1, sizeof(::tensorflow::OpInfo_TensorProperties)},
  { 26, -1, -1, sizeof(::tensorflow::OpInfo)},
  { 38, -1, -1, sizeof(::tensorflow::NormalDistribution)},
  { 46, -1, -1, sizeof(::tensorflow::LogNormalDistribution)},
  { 54, -1, -1, sizeof(::tensorflow::OpPerformance_OpMemory)},
  { 65, -1, -1, sizeof(::tensorflow::OpPerformance)},
  { 84, -1, -1, sizeof(::tensorflow::OpPerformanceList)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::tensorflow::_SessionInfo_default_instance_._instance,
  &::tensorflow::_OpInfo_AttrEntry_DoNotUse_default_instance_._instance,
  &::tensorflow::_OpInfo_TensorProperties_default_instance_._instance,
  &::tensorflow::_OpInfo_default_instance_._instance,
  &::tensorflow::_NormalDistribution_default_instance_._instance,
  &::tensorflow::_LogNormalDistribution_default_instance_._instance,
  &::tensorflow::_OpPerformance_OpMemory_default_instance_._instance,
  &::tensorflow::_OpPerformance_default_instance_._instance,
  &::tensorflow::_OpPerformanceList_default_instance_._instance,
};

const char descriptor_table_protodef_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n8tensorflow/core/grappler/costs/op_perf"
  "ormance_data.proto\022\ntensorflow\032&tensorfl"
  "ow/core/framework/tensor.proto\032,tensorfl"
  "ow/core/framework/tensor_shape.proto\032%te"
  "nsorflow/core/framework/types.proto\032*ten"
  "sorflow/core/framework/attr_value.proto\032"
  "0tensorflow/core/protobuf/device_propert"
  "ies.proto\"+\n\013SessionInfo\022\034\n\024intra_op_par"
  "allelism\030\001 \001(\003\"\333\003\n\006OpInfo\022\n\n\002op\030\001 \001(\t\022*\n"
  "\004attr\030\002 \003(\0132\034.tensorflow.OpInfo.AttrEntr"
  "y\0223\n\006inputs\030\003 \003(\0132#.tensorflow.OpInfo.Te"
  "nsorProperties\0224\n\007outputs\030\005 \003(\0132#.tensor"
  "flow.OpInfo.TensorProperties\022,\n\006device\030\004"
  " \001(\0132\034.tensorflow.DeviceProperties\022-\n\014se"
  "ssion_info\030\006 \001(\0132\027.tensorflow.SessionInf"
  "o\032B\n\tAttrEntry\022\013\n\003key\030\001 \001(\t\022$\n\005value\030\002 \001"
  "(\0132\025.tensorflow.AttrValue:\0028\001\032\214\001\n\020Tensor"
  "Properties\022#\n\005dtype\030\001 \001(\0162\024.tensorflow.D"
  "ataType\022+\n\005shape\030\002 \001(\0132\034.tensorflow.Tens"
  "orShapeProto\022&\n\005value\030\003 \001(\0132\027.tensorflow"
  ".TensorProto\"/\n\022NormalDistribution\022\n\n\002mu"
  "\030\001 \001(\001\022\r\n\005sigma\030\002 \001(\001\"2\n\025LogNormalDistri"
  "bution\022\n\n\002mu\030\001 \001(\001\022\r\n\005sigma\030\002 \001(\001\"\363\004\n\rOp"
  "Performance\022\036\n\002op\030\001 \001(\0132\022.tensorflow.OpI"
  "nfo\0221\n\014session_info\030\014 \001(\0132\027.tensorflow.S"
  "essionInfoB\002\030\001\022\014\n\004node\030\005 \001(\t\022\035\n\025temporar"
  "y_memory_size\030\002 \001(\003\022\024\n\014compute_cost\030\003 \001("
  "\003\022\024\n\014compute_time\030\006 \001(\003\022\023\n\013memory_time\030\007"
  " \001(\003\022\032\n\022compute_efficiency\030\004 \001(\001\022\031\n\021memo"
  "ry_efficiency\030\010 \001(\001\022\?\n\025execution_time_no"
  "rmal\030\n \001(\0132\036.tensorflow.NormalDistributi"
  "onH\000\022F\n\031execution_time_log_normal\030\013 \001(\0132"
  "!.tensorflow.LogNormalDistributionH\000\0225\n\t"
  "op_memory\030\t \001(\0132\".tensorflow.OpPerforman"
  "ce.OpMemory\032\227\001\n\010OpMemory\022\025\n\routput_memor"
  "y\030\001 \003(\003\022\023\n\013temp_memory\030\002 \001(\003\022\031\n\021persiste"
  "nt_memory\030\004 \001(\003\022\036\n\022device_temp_memory\030\003 "
  "\001(\003B\002\030\001\022$\n\030device_persistent_memory\030\005 \001("
  "\003B\002\030\001B\020\n\016execution_time\"F\n\021OpPerformance"
  "List\0221\n\016op_performance\030\001 \003(\0132\031.tensorflo"
  "w.OpPerformanceB\003\370\001\001b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_deps[5] = {
  &::descriptor_table_tensorflow_2fcore_2fframework_2fattr_5fvalue_2eproto,
  &::descriptor_table_tensorflow_2fcore_2fframework_2ftensor_2eproto,
  &::descriptor_table_tensorflow_2fcore_2fframework_2ftensor_5fshape_2eproto,
  &::descriptor_table_tensorflow_2fcore_2fframework_2ftypes_2eproto,
  &::descriptor_table_tensorflow_2fcore_2fprotobuf_2fdevice_5fproperties_2eproto,
};
static ::_pbi::once_flag descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto = {
    false, false, 1628, descriptor_table_protodef_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto,
    "tensorflow/core/grappler/costs/op_performance_data.proto",
    &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_once, descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_deps, 5, 9,
    schemas, file_default_instances, TableStruct_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto::offsets,
    file_level_metadata_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto, file_level_enum_descriptors_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto,
    file_level_service_descriptors_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_getter() {
  return &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto(&descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto);
namespace tensorflow {

// ===================================================================

class SessionInfo::_Internal {
 public:
};

SessionInfo::SessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.SessionInfo)
}
SessionInfo::SessionInfo(const SessionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SessionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.intra_op_parallelism_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.intra_op_parallelism_ = from._impl_.intra_op_parallelism_;
  // @@protoc_insertion_point(copy_constructor:tensorflow.SessionInfo)
}

inline void SessionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.intra_op_parallelism_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SessionInfo::~SessionInfo() {
  // @@protoc_insertion_point(destructor:tensorflow.SessionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SessionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SessionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SessionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.SessionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.intra_op_parallelism_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SessionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 intra_op_parallelism = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.intra_op_parallelism_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SessionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.SessionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 intra_op_parallelism = 1;
  if (this->_internal_intra_op_parallelism() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_intra_op_parallelism(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.SessionInfo)
  return target;
}

size_t SessionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.SessionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 intra_op_parallelism = 1;
  if (this->_internal_intra_op_parallelism() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_intra_op_parallelism());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SessionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SessionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SessionInfo::GetClassData() const { return &_class_data_; }


void SessionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SessionInfo*>(&to_msg);
  auto& from = static_cast<const SessionInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.SessionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_intra_op_parallelism() != 0) {
    _this->_internal_set_intra_op_parallelism(from._internal_intra_op_parallelism());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SessionInfo::CopyFrom(const SessionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.SessionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionInfo::IsInitialized() const {
  return true;
}

void SessionInfo::InternalSwap(SessionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.intra_op_parallelism_, other->_impl_.intra_op_parallelism_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SessionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto[0]);
}

// ===================================================================

OpInfo_AttrEntry_DoNotUse::OpInfo_AttrEntry_DoNotUse() {}
OpInfo_AttrEntry_DoNotUse::OpInfo_AttrEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void OpInfo_AttrEntry_DoNotUse::MergeFrom(const OpInfo_AttrEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata OpInfo_AttrEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto[1]);
}

// ===================================================================

class OpInfo_TensorProperties::_Internal {
 public:
  static const ::tensorflow::TensorShapeProto& shape(const OpInfo_TensorProperties* msg);
  static const ::tensorflow::TensorProto& value(const OpInfo_TensorProperties* msg);
};

const ::tensorflow::TensorShapeProto&
OpInfo_TensorProperties::_Internal::shape(const OpInfo_TensorProperties* msg) {
  return *msg->_impl_.shape_;
}
const ::tensorflow::TensorProto&
OpInfo_TensorProperties::_Internal::value(const OpInfo_TensorProperties* msg) {
  return *msg->_impl_.value_;
}
void OpInfo_TensorProperties::clear_shape() {
  if (GetArenaForAllocation() == nullptr && _impl_.shape_ != nullptr) {
    delete _impl_.shape_;
  }
  _impl_.shape_ = nullptr;
}
void OpInfo_TensorProperties::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
OpInfo_TensorProperties::OpInfo_TensorProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.OpInfo.TensorProperties)
}
OpInfo_TensorProperties::OpInfo_TensorProperties(const OpInfo_TensorProperties& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OpInfo_TensorProperties* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shape_){nullptr}
    , decltype(_impl_.value_){nullptr}
    , decltype(_impl_.dtype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_shape()) {
    _this->_impl_.shape_ = new ::tensorflow::TensorShapeProto(*from._impl_.shape_);
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::tensorflow::TensorProto(*from._impl_.value_);
  }
  _this->_impl_.dtype_ = from._impl_.dtype_;
  // @@protoc_insertion_point(copy_constructor:tensorflow.OpInfo.TensorProperties)
}

inline void OpInfo_TensorProperties::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.shape_){nullptr}
    , decltype(_impl_.value_){nullptr}
    , decltype(_impl_.dtype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OpInfo_TensorProperties::~OpInfo_TensorProperties() {
  // @@protoc_insertion_point(destructor:tensorflow.OpInfo.TensorProperties)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OpInfo_TensorProperties::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.shape_;
  if (this != internal_default_instance()) delete _impl_.value_;
}

void OpInfo_TensorProperties::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OpInfo_TensorProperties::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.OpInfo.TensorProperties)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.shape_ != nullptr) {
    delete _impl_.shape_;
  }
  _impl_.shape_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _impl_.dtype_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpInfo_TensorProperties::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tensorflow.DataType dtype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_dtype(static_cast<::tensorflow::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.TensorShapeProto shape = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.TensorProto value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OpInfo_TensorProperties::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.OpInfo.TensorProperties)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tensorflow.DataType dtype = 1;
  if (this->_internal_dtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_dtype(), target);
  }

  // .tensorflow.TensorShapeProto shape = 2;
  if (this->_internal_has_shape()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::shape(this),
        _Internal::shape(this).GetCachedSize(), target, stream);
  }

  // .tensorflow.TensorProto value = 3;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.OpInfo.TensorProperties)
  return target;
}

size_t OpInfo_TensorProperties::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.OpInfo.TensorProperties)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .tensorflow.TensorShapeProto shape = 2;
  if (this->_internal_has_shape()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.shape_);
  }

  // .tensorflow.TensorProto value = 3;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  // .tensorflow.DataType dtype = 1;
  if (this->_internal_dtype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dtype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OpInfo_TensorProperties::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OpInfo_TensorProperties::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OpInfo_TensorProperties::GetClassData() const { return &_class_data_; }


void OpInfo_TensorProperties::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OpInfo_TensorProperties*>(&to_msg);
  auto& from = static_cast<const OpInfo_TensorProperties&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.OpInfo.TensorProperties)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_shape()) {
    _this->_internal_mutable_shape()->::tensorflow::TensorShapeProto::MergeFrom(
        from._internal_shape());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::tensorflow::TensorProto::MergeFrom(
        from._internal_value());
  }
  if (from._internal_dtype() != 0) {
    _this->_internal_set_dtype(from._internal_dtype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OpInfo_TensorProperties::CopyFrom(const OpInfo_TensorProperties& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.OpInfo.TensorProperties)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpInfo_TensorProperties::IsInitialized() const {
  return true;
}

void OpInfo_TensorProperties::InternalSwap(OpInfo_TensorProperties* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OpInfo_TensorProperties, _impl_.dtype_)
      + sizeof(OpInfo_TensorProperties::_impl_.dtype_)
      - PROTOBUF_FIELD_OFFSET(OpInfo_TensorProperties, _impl_.shape_)>(
          reinterpret_cast<char*>(&_impl_.shape_),
          reinterpret_cast<char*>(&other->_impl_.shape_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OpInfo_TensorProperties::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto[2]);
}

// ===================================================================

class OpInfo::_Internal {
 public:
  static const ::tensorflow::DeviceProperties& device(const OpInfo* msg);
  static const ::tensorflow::SessionInfo& session_info(const OpInfo* msg);
};

const ::tensorflow::DeviceProperties&
OpInfo::_Internal::device(const OpInfo* msg) {
  return *msg->_impl_.device_;
}
const ::tensorflow::SessionInfo&
OpInfo::_Internal::session_info(const OpInfo* msg) {
  return *msg->_impl_.session_info_;
}
void OpInfo::clear_attr() {
  _impl_.attr_.Clear();
}
void OpInfo::clear_device() {
  if (GetArenaForAllocation() == nullptr && _impl_.device_ != nullptr) {
    delete _impl_.device_;
  }
  _impl_.device_ = nullptr;
}
OpInfo::OpInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &OpInfo::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:tensorflow.OpInfo)
}
OpInfo::OpInfo(const OpInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OpInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.attr_)*/{}
    , decltype(_impl_.inputs_){from._impl_.inputs_}
    , decltype(_impl_.outputs_){from._impl_.outputs_}
    , decltype(_impl_.op_){}
    , decltype(_impl_.device_){nullptr}
    , decltype(_impl_.session_info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.attr_.MergeFrom(from._impl_.attr_);
  _impl_.op_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.op_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_op().empty()) {
    _this->_impl_.op_.Set(from._internal_op(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_device()) {
    _this->_impl_.device_ = new ::tensorflow::DeviceProperties(*from._impl_.device_);
  }
  if (from._internal_has_session_info()) {
    _this->_impl_.session_info_ = new ::tensorflow::SessionInfo(*from._impl_.session_info_);
  }
  // @@protoc_insertion_point(copy_constructor:tensorflow.OpInfo)
}

inline void OpInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.attr_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.inputs_){arena}
    , decltype(_impl_.outputs_){arena}
    , decltype(_impl_.op_){}
    , decltype(_impl_.device_){nullptr}
    , decltype(_impl_.session_info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.op_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.op_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OpInfo::~OpInfo() {
  // @@protoc_insertion_point(destructor:tensorflow.OpInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void OpInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attr_.Destruct();
  _impl_.attr_.~MapField();
  _impl_.inputs_.~RepeatedPtrField();
  _impl_.outputs_.~RepeatedPtrField();
  _impl_.op_.Destroy();
  if (this != internal_default_instance()) delete _impl_.device_;
  if (this != internal_default_instance()) delete _impl_.session_info_;
}

void OpInfo::ArenaDtor(void* object) {
  OpInfo* _this = reinterpret_cast< OpInfo* >(object);
  _this->_impl_.attr_.Destruct();
}
void OpInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OpInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.OpInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attr_.Clear();
  _impl_.inputs_.Clear();
  _impl_.outputs_.Clear();
  _impl_.op_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.device_ != nullptr) {
    delete _impl_.device_;
  }
  _impl_.device_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.session_info_ != nullptr) {
    delete _impl_.session_info_;
  }
  _impl_.session_info_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_op();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tensorflow.OpInfo.op"));
        } else
          goto handle_unusual;
        continue;
      // map<string, .tensorflow.AttrValue> attr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.attr_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .tensorflow.OpInfo.TensorProperties inputs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inputs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.DeviceProperties device = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_device(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .tensorflow.OpInfo.TensorProperties outputs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_outputs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.SessionInfo session_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_session_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OpInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.OpInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string op = 1;
  if (!this->_internal_op().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_op().data(), static_cast<int>(this->_internal_op().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tensorflow.OpInfo.op");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_op(), target);
  }

  // map<string, .tensorflow.AttrValue> attr = 2;
  if (!this->_internal_attr().empty()) {
    using MapType = ::_pb::Map<std::string, ::tensorflow::AttrValue>;
    using WireHelper = OpInfo_AttrEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_attr();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "tensorflow.OpInfo.AttrEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // repeated .tensorflow.OpInfo.TensorProperties inputs = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_inputs_size()); i < n; i++) {
    const auto& repfield = this->_internal_inputs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .tensorflow.DeviceProperties device = 4;
  if (this->_internal_has_device()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::device(this),
        _Internal::device(this).GetCachedSize(), target, stream);
  }

  // repeated .tensorflow.OpInfo.TensorProperties outputs = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outputs_size()); i < n; i++) {
    const auto& repfield = this->_internal_outputs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .tensorflow.SessionInfo session_info = 6;
  if (this->_internal_has_session_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::session_info(this),
        _Internal::session_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.OpInfo)
  return target;
}

size_t OpInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.OpInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .tensorflow.AttrValue> attr = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_attr_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tensorflow::AttrValue >::const_iterator
      it = this->_internal_attr().begin();
      it != this->_internal_attr().end(); ++it) {
    total_size += OpInfo_AttrEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .tensorflow.OpInfo.TensorProperties inputs = 3;
  total_size += 1UL * this->_internal_inputs_size();
  for (const auto& msg : this->_impl_.inputs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .tensorflow.OpInfo.TensorProperties outputs = 5;
  total_size += 1UL * this->_internal_outputs_size();
  for (const auto& msg : this->_impl_.outputs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string op = 1;
  if (!this->_internal_op().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_op());
  }

  // .tensorflow.DeviceProperties device = 4;
  if (this->_internal_has_device()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.device_);
  }

  // .tensorflow.SessionInfo session_info = 6;
  if (this->_internal_has_session_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.session_info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OpInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OpInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OpInfo::GetClassData() const { return &_class_data_; }


void OpInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OpInfo*>(&to_msg);
  auto& from = static_cast<const OpInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.OpInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attr_.MergeFrom(from._impl_.attr_);
  _this->_impl_.inputs_.MergeFrom(from._impl_.inputs_);
  _this->_impl_.outputs_.MergeFrom(from._impl_.outputs_);
  if (!from._internal_op().empty()) {
    _this->_internal_set_op(from._internal_op());
  }
  if (from._internal_has_device()) {
    _this->_internal_mutable_device()->::tensorflow::DeviceProperties::MergeFrom(
        from._internal_device());
  }
  if (from._internal_has_session_info()) {
    _this->_internal_mutable_session_info()->::tensorflow::SessionInfo::MergeFrom(
        from._internal_session_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OpInfo::CopyFrom(const OpInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.OpInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpInfo::IsInitialized() const {
  return true;
}

void OpInfo::InternalSwap(OpInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.attr_.InternalSwap(&other->_impl_.attr_);
  _impl_.inputs_.InternalSwap(&other->_impl_.inputs_);
  _impl_.outputs_.InternalSwap(&other->_impl_.outputs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.op_, lhs_arena,
      &other->_impl_.op_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OpInfo, _impl_.session_info_)
      + sizeof(OpInfo::_impl_.session_info_)
      - PROTOBUF_FIELD_OFFSET(OpInfo, _impl_.device_)>(
          reinterpret_cast<char*>(&_impl_.device_),
          reinterpret_cast<char*>(&other->_impl_.device_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OpInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto[3]);
}

// ===================================================================

class NormalDistribution::_Internal {
 public:
};

NormalDistribution::NormalDistribution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.NormalDistribution)
}
NormalDistribution::NormalDistribution(const NormalDistribution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NormalDistribution* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mu_){}
    , decltype(_impl_.sigma_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.mu_, &from._impl_.mu_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sigma_) -
    reinterpret_cast<char*>(&_impl_.mu_)) + sizeof(_impl_.sigma_));
  // @@protoc_insertion_point(copy_constructor:tensorflow.NormalDistribution)
}

inline void NormalDistribution::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.mu_){0}
    , decltype(_impl_.sigma_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NormalDistribution::~NormalDistribution() {
  // @@protoc_insertion_point(destructor:tensorflow.NormalDistribution)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NormalDistribution::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NormalDistribution::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NormalDistribution::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.NormalDistribution)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.mu_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.sigma_) -
      reinterpret_cast<char*>(&_impl_.mu_)) + sizeof(_impl_.sigma_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NormalDistribution::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double mu = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.mu_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double sigma = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.sigma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NormalDistribution::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.NormalDistribution)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double mu = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mu = this->_internal_mu();
  uint64_t raw_mu;
  memcpy(&raw_mu, &tmp_mu, sizeof(tmp_mu));
  if (raw_mu != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_mu(), target);
  }

  // double sigma = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sigma = this->_internal_sigma();
  uint64_t raw_sigma;
  memcpy(&raw_sigma, &tmp_sigma, sizeof(tmp_sigma));
  if (raw_sigma != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_sigma(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.NormalDistribution)
  return target;
}

size_t NormalDistribution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.NormalDistribution)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double mu = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mu = this->_internal_mu();
  uint64_t raw_mu;
  memcpy(&raw_mu, &tmp_mu, sizeof(tmp_mu));
  if (raw_mu != 0) {
    total_size += 1 + 8;
  }

  // double sigma = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sigma = this->_internal_sigma();
  uint64_t raw_sigma;
  memcpy(&raw_sigma, &tmp_sigma, sizeof(tmp_sigma));
  if (raw_sigma != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NormalDistribution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NormalDistribution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NormalDistribution::GetClassData() const { return &_class_data_; }


void NormalDistribution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NormalDistribution*>(&to_msg);
  auto& from = static_cast<const NormalDistribution&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.NormalDistribution)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mu = from._internal_mu();
  uint64_t raw_mu;
  memcpy(&raw_mu, &tmp_mu, sizeof(tmp_mu));
  if (raw_mu != 0) {
    _this->_internal_set_mu(from._internal_mu());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sigma = from._internal_sigma();
  uint64_t raw_sigma;
  memcpy(&raw_sigma, &tmp_sigma, sizeof(tmp_sigma));
  if (raw_sigma != 0) {
    _this->_internal_set_sigma(from._internal_sigma());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NormalDistribution::CopyFrom(const NormalDistribution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.NormalDistribution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NormalDistribution::IsInitialized() const {
  return true;
}

void NormalDistribution::InternalSwap(NormalDistribution* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NormalDistribution, _impl_.sigma_)
      + sizeof(NormalDistribution::_impl_.sigma_)
      - PROTOBUF_FIELD_OFFSET(NormalDistribution, _impl_.mu_)>(
          reinterpret_cast<char*>(&_impl_.mu_),
          reinterpret_cast<char*>(&other->_impl_.mu_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NormalDistribution::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto[4]);
}

// ===================================================================

class LogNormalDistribution::_Internal {
 public:
};

LogNormalDistribution::LogNormalDistribution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.LogNormalDistribution)
}
LogNormalDistribution::LogNormalDistribution(const LogNormalDistribution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LogNormalDistribution* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mu_){}
    , decltype(_impl_.sigma_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.mu_, &from._impl_.mu_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sigma_) -
    reinterpret_cast<char*>(&_impl_.mu_)) + sizeof(_impl_.sigma_));
  // @@protoc_insertion_point(copy_constructor:tensorflow.LogNormalDistribution)
}

inline void LogNormalDistribution::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.mu_){0}
    , decltype(_impl_.sigma_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LogNormalDistribution::~LogNormalDistribution() {
  // @@protoc_insertion_point(destructor:tensorflow.LogNormalDistribution)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogNormalDistribution::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LogNormalDistribution::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogNormalDistribution::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.LogNormalDistribution)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.mu_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.sigma_) -
      reinterpret_cast<char*>(&_impl_.mu_)) + sizeof(_impl_.sigma_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogNormalDistribution::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double mu = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.mu_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double sigma = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.sigma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogNormalDistribution::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.LogNormalDistribution)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double mu = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mu = this->_internal_mu();
  uint64_t raw_mu;
  memcpy(&raw_mu, &tmp_mu, sizeof(tmp_mu));
  if (raw_mu != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_mu(), target);
  }

  // double sigma = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sigma = this->_internal_sigma();
  uint64_t raw_sigma;
  memcpy(&raw_sigma, &tmp_sigma, sizeof(tmp_sigma));
  if (raw_sigma != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_sigma(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.LogNormalDistribution)
  return target;
}

size_t LogNormalDistribution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.LogNormalDistribution)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double mu = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mu = this->_internal_mu();
  uint64_t raw_mu;
  memcpy(&raw_mu, &tmp_mu, sizeof(tmp_mu));
  if (raw_mu != 0) {
    total_size += 1 + 8;
  }

  // double sigma = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sigma = this->_internal_sigma();
  uint64_t raw_sigma;
  memcpy(&raw_sigma, &tmp_sigma, sizeof(tmp_sigma));
  if (raw_sigma != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogNormalDistribution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LogNormalDistribution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogNormalDistribution::GetClassData() const { return &_class_data_; }


void LogNormalDistribution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LogNormalDistribution*>(&to_msg);
  auto& from = static_cast<const LogNormalDistribution&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.LogNormalDistribution)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mu = from._internal_mu();
  uint64_t raw_mu;
  memcpy(&raw_mu, &tmp_mu, sizeof(tmp_mu));
  if (raw_mu != 0) {
    _this->_internal_set_mu(from._internal_mu());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sigma = from._internal_sigma();
  uint64_t raw_sigma;
  memcpy(&raw_sigma, &tmp_sigma, sizeof(tmp_sigma));
  if (raw_sigma != 0) {
    _this->_internal_set_sigma(from._internal_sigma());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogNormalDistribution::CopyFrom(const LogNormalDistribution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.LogNormalDistribution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogNormalDistribution::IsInitialized() const {
  return true;
}

void LogNormalDistribution::InternalSwap(LogNormalDistribution* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogNormalDistribution, _impl_.sigma_)
      + sizeof(LogNormalDistribution::_impl_.sigma_)
      - PROTOBUF_FIELD_OFFSET(LogNormalDistribution, _impl_.mu_)>(
          reinterpret_cast<char*>(&_impl_.mu_),
          reinterpret_cast<char*>(&other->_impl_.mu_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LogNormalDistribution::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto[5]);
}

// ===================================================================

class OpPerformance_OpMemory::_Internal {
 public:
};

OpPerformance_OpMemory::OpPerformance_OpMemory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.OpPerformance.OpMemory)
}
OpPerformance_OpMemory::OpPerformance_OpMemory(const OpPerformance_OpMemory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OpPerformance_OpMemory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.output_memory_){from._impl_.output_memory_}
    , /*decltype(_impl_._output_memory_cached_byte_size_)*/{0}
    , decltype(_impl_.temp_memory_){}
    , decltype(_impl_.device_temp_memory_){}
    , decltype(_impl_.persistent_memory_){}
    , decltype(_impl_.device_persistent_memory_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.temp_memory_, &from._impl_.temp_memory_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.device_persistent_memory_) -
    reinterpret_cast<char*>(&_impl_.temp_memory_)) + sizeof(_impl_.device_persistent_memory_));
  // @@protoc_insertion_point(copy_constructor:tensorflow.OpPerformance.OpMemory)
}

inline void OpPerformance_OpMemory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.output_memory_){arena}
    , /*decltype(_impl_._output_memory_cached_byte_size_)*/{0}
    , decltype(_impl_.temp_memory_){int64_t{0}}
    , decltype(_impl_.device_temp_memory_){int64_t{0}}
    , decltype(_impl_.persistent_memory_){int64_t{0}}
    , decltype(_impl_.device_persistent_memory_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OpPerformance_OpMemory::~OpPerformance_OpMemory() {
  // @@protoc_insertion_point(destructor:tensorflow.OpPerformance.OpMemory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OpPerformance_OpMemory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.output_memory_.~RepeatedField();
}

void OpPerformance_OpMemory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OpPerformance_OpMemory::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.OpPerformance.OpMemory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.output_memory_.Clear();
  ::memset(&_impl_.temp_memory_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.device_persistent_memory_) -
      reinterpret_cast<char*>(&_impl_.temp_memory_)) + sizeof(_impl_.device_persistent_memory_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpPerformance_OpMemory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 output_memory = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_output_memory(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_output_memory(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 temp_memory = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.temp_memory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 device_temp_memory = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.device_temp_memory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 persistent_memory = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.persistent_memory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 device_persistent_memory = 5 [deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.device_persistent_memory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OpPerformance_OpMemory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.OpPerformance.OpMemory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 output_memory = 1;
  {
    int byte_size = _impl_._output_memory_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_output_memory(), byte_size, target);
    }
  }

  // int64 temp_memory = 2;
  if (this->_internal_temp_memory() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_temp_memory(), target);
  }

  // int64 device_temp_memory = 3 [deprecated = true];
  if (this->_internal_device_temp_memory() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_device_temp_memory(), target);
  }

  // int64 persistent_memory = 4;
  if (this->_internal_persistent_memory() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_persistent_memory(), target);
  }

  // int64 device_persistent_memory = 5 [deprecated = true];
  if (this->_internal_device_persistent_memory() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_device_persistent_memory(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.OpPerformance.OpMemory)
  return target;
}

size_t OpPerformance_OpMemory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.OpPerformance.OpMemory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 output_memory = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.output_memory_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._output_memory_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 temp_memory = 2;
  if (this->_internal_temp_memory() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_temp_memory());
  }

  // int64 device_temp_memory = 3 [deprecated = true];
  if (this->_internal_device_temp_memory() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_device_temp_memory());
  }

  // int64 persistent_memory = 4;
  if (this->_internal_persistent_memory() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_persistent_memory());
  }

  // int64 device_persistent_memory = 5 [deprecated = true];
  if (this->_internal_device_persistent_memory() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_device_persistent_memory());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OpPerformance_OpMemory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OpPerformance_OpMemory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OpPerformance_OpMemory::GetClassData() const { return &_class_data_; }


void OpPerformance_OpMemory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OpPerformance_OpMemory*>(&to_msg);
  auto& from = static_cast<const OpPerformance_OpMemory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.OpPerformance.OpMemory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.output_memory_.MergeFrom(from._impl_.output_memory_);
  if (from._internal_temp_memory() != 0) {
    _this->_internal_set_temp_memory(from._internal_temp_memory());
  }
  if (from._internal_device_temp_memory() != 0) {
    _this->_internal_set_device_temp_memory(from._internal_device_temp_memory());
  }
  if (from._internal_persistent_memory() != 0) {
    _this->_internal_set_persistent_memory(from._internal_persistent_memory());
  }
  if (from._internal_device_persistent_memory() != 0) {
    _this->_internal_set_device_persistent_memory(from._internal_device_persistent_memory());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OpPerformance_OpMemory::CopyFrom(const OpPerformance_OpMemory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.OpPerformance.OpMemory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpPerformance_OpMemory::IsInitialized() const {
  return true;
}

void OpPerformance_OpMemory::InternalSwap(OpPerformance_OpMemory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.output_memory_.InternalSwap(&other->_impl_.output_memory_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OpPerformance_OpMemory, _impl_.device_persistent_memory_)
      + sizeof(OpPerformance_OpMemory::_impl_.device_persistent_memory_)
      - PROTOBUF_FIELD_OFFSET(OpPerformance_OpMemory, _impl_.temp_memory_)>(
          reinterpret_cast<char*>(&_impl_.temp_memory_),
          reinterpret_cast<char*>(&other->_impl_.temp_memory_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OpPerformance_OpMemory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto[6]);
}

// ===================================================================

class OpPerformance::_Internal {
 public:
  static const ::tensorflow::OpInfo& op(const OpPerformance* msg);
  static const ::tensorflow::SessionInfo& session_info(const OpPerformance* msg);
  static const ::tensorflow::NormalDistribution& execution_time_normal(const OpPerformance* msg);
  static const ::tensorflow::LogNormalDistribution& execution_time_log_normal(const OpPerformance* msg);
  static const ::tensorflow::OpPerformance_OpMemory& op_memory(const OpPerformance* msg);
};

const ::tensorflow::OpInfo&
OpPerformance::_Internal::op(const OpPerformance* msg) {
  return *msg->_impl_.op_;
}
const ::tensorflow::SessionInfo&
OpPerformance::_Internal::session_info(const OpPerformance* msg) {
  return *msg->_impl_.session_info_;
}
const ::tensorflow::NormalDistribution&
OpPerformance::_Internal::execution_time_normal(const OpPerformance* msg) {
  return *msg->_impl_.execution_time_.execution_time_normal_;
}
const ::tensorflow::LogNormalDistribution&
OpPerformance::_Internal::execution_time_log_normal(const OpPerformance* msg) {
  return *msg->_impl_.execution_time_.execution_time_log_normal_;
}
const ::tensorflow::OpPerformance_OpMemory&
OpPerformance::_Internal::op_memory(const OpPerformance* msg) {
  return *msg->_impl_.op_memory_;
}
void OpPerformance::set_allocated_execution_time_normal(::tensorflow::NormalDistribution* execution_time_normal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_execution_time();
  if (execution_time_normal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(execution_time_normal);
    if (message_arena != submessage_arena) {
      execution_time_normal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, execution_time_normal, submessage_arena);
    }
    set_has_execution_time_normal();
    _impl_.execution_time_.execution_time_normal_ = execution_time_normal;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.OpPerformance.execution_time_normal)
}
void OpPerformance::set_allocated_execution_time_log_normal(::tensorflow::LogNormalDistribution* execution_time_log_normal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_execution_time();
  if (execution_time_log_normal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(execution_time_log_normal);
    if (message_arena != submessage_arena) {
      execution_time_log_normal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, execution_time_log_normal, submessage_arena);
    }
    set_has_execution_time_log_normal();
    _impl_.execution_time_.execution_time_log_normal_ = execution_time_log_normal;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.OpPerformance.execution_time_log_normal)
}
OpPerformance::OpPerformance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.OpPerformance)
}
OpPerformance::OpPerformance(const OpPerformance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OpPerformance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.node_){}
    , decltype(_impl_.op_){nullptr}
    , decltype(_impl_.op_memory_){nullptr}
    , decltype(_impl_.session_info_){nullptr}
    , decltype(_impl_.temporary_memory_size_){}
    , decltype(_impl_.compute_cost_){}
    , decltype(_impl_.compute_efficiency_){}
    , decltype(_impl_.compute_time_){}
    , decltype(_impl_.memory_time_){}
    , decltype(_impl_.memory_efficiency_){}
    , decltype(_impl_.execution_time_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.node_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.node_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_node().empty()) {
    _this->_impl_.node_.Set(from._internal_node(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_op()) {
    _this->_impl_.op_ = new ::tensorflow::OpInfo(*from._impl_.op_);
  }
  if (from._internal_has_op_memory()) {
    _this->_impl_.op_memory_ = new ::tensorflow::OpPerformance_OpMemory(*from._impl_.op_memory_);
  }
  if (from._internal_has_session_info()) {
    _this->_impl_.session_info_ = new ::tensorflow::SessionInfo(*from._impl_.session_info_);
  }
  ::memcpy(&_impl_.temporary_memory_size_, &from._impl_.temporary_memory_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.memory_efficiency_) -
    reinterpret_cast<char*>(&_impl_.temporary_memory_size_)) + sizeof(_impl_.memory_efficiency_));
  clear_has_execution_time();
  switch (from.execution_time_case()) {
    case kExecutionTimeNormal: {
      _this->_internal_mutable_execution_time_normal()->::tensorflow::NormalDistribution::MergeFrom(
          from._internal_execution_time_normal());
      break;
    }
    case kExecutionTimeLogNormal: {
      _this->_internal_mutable_execution_time_log_normal()->::tensorflow::LogNormalDistribution::MergeFrom(
          from._internal_execution_time_log_normal());
      break;
    }
    case EXECUTION_TIME_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:tensorflow.OpPerformance)
}

inline void OpPerformance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.node_){}
    , decltype(_impl_.op_){nullptr}
    , decltype(_impl_.op_memory_){nullptr}
    , decltype(_impl_.session_info_){nullptr}
    , decltype(_impl_.temporary_memory_size_){int64_t{0}}
    , decltype(_impl_.compute_cost_){int64_t{0}}
    , decltype(_impl_.compute_efficiency_){0}
    , decltype(_impl_.compute_time_){int64_t{0}}
    , decltype(_impl_.memory_time_){int64_t{0}}
    , decltype(_impl_.memory_efficiency_){0}
    , decltype(_impl_.execution_time_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.node_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.node_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_execution_time();
}

OpPerformance::~OpPerformance() {
  // @@protoc_insertion_point(destructor:tensorflow.OpPerformance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OpPerformance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.node_.Destroy();
  if (this != internal_default_instance()) delete _impl_.op_;
  if (this != internal_default_instance()) delete _impl_.op_memory_;
  if (this != internal_default_instance()) delete _impl_.session_info_;
  if (has_execution_time()) {
    clear_execution_time();
  }
}

void OpPerformance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OpPerformance::clear_execution_time() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.OpPerformance)
  switch (execution_time_case()) {
    case kExecutionTimeNormal: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.execution_time_.execution_time_normal_;
      }
      break;
    }
    case kExecutionTimeLogNormal: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.execution_time_.execution_time_log_normal_;
      }
      break;
    }
    case EXECUTION_TIME_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = EXECUTION_TIME_NOT_SET;
}


void OpPerformance::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.OpPerformance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.node_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.op_ != nullptr) {
    delete _impl_.op_;
  }
  _impl_.op_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.op_memory_ != nullptr) {
    delete _impl_.op_memory_;
  }
  _impl_.op_memory_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.session_info_ != nullptr) {
    delete _impl_.session_info_;
  }
  _impl_.session_info_ = nullptr;
  ::memset(&_impl_.temporary_memory_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.memory_efficiency_) -
      reinterpret_cast<char*>(&_impl_.temporary_memory_size_)) + sizeof(_impl_.memory_efficiency_));
  clear_execution_time();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpPerformance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .tensorflow.OpInfo op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_op(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 temporary_memory_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.temporary_memory_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 compute_cost = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.compute_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double compute_efficiency = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.compute_efficiency_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string node = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_node();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "tensorflow.OpPerformance.node"));
        } else
          goto handle_unusual;
        continue;
      // int64 compute_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.compute_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 memory_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.memory_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double memory_efficiency = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.memory_efficiency_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.OpPerformance.OpMemory op_memory = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_op_memory(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.NormalDistribution execution_time_normal = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_execution_time_normal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.LogNormalDistribution execution_time_log_normal = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_execution_time_log_normal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tensorflow.SessionInfo session_info = 12 [deprecated = true];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_session_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OpPerformance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.OpPerformance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .tensorflow.OpInfo op = 1;
  if (this->_internal_has_op()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::op(this),
        _Internal::op(this).GetCachedSize(), target, stream);
  }

  // int64 temporary_memory_size = 2;
  if (this->_internal_temporary_memory_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_temporary_memory_size(), target);
  }

  // int64 compute_cost = 3;
  if (this->_internal_compute_cost() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_compute_cost(), target);
  }

  // double compute_efficiency = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_compute_efficiency = this->_internal_compute_efficiency();
  uint64_t raw_compute_efficiency;
  memcpy(&raw_compute_efficiency, &tmp_compute_efficiency, sizeof(tmp_compute_efficiency));
  if (raw_compute_efficiency != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_compute_efficiency(), target);
  }

  // string node = 5;
  if (!this->_internal_node().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_node().data(), static_cast<int>(this->_internal_node().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "tensorflow.OpPerformance.node");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_node(), target);
  }

  // int64 compute_time = 6;
  if (this->_internal_compute_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_compute_time(), target);
  }

  // int64 memory_time = 7;
  if (this->_internal_memory_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_memory_time(), target);
  }

  // double memory_efficiency = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_memory_efficiency = this->_internal_memory_efficiency();
  uint64_t raw_memory_efficiency;
  memcpy(&raw_memory_efficiency, &tmp_memory_efficiency, sizeof(tmp_memory_efficiency));
  if (raw_memory_efficiency != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_memory_efficiency(), target);
  }

  // .tensorflow.OpPerformance.OpMemory op_memory = 9;
  if (this->_internal_has_op_memory()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::op_memory(this),
        _Internal::op_memory(this).GetCachedSize(), target, stream);
  }

  // .tensorflow.NormalDistribution execution_time_normal = 10;
  if (_internal_has_execution_time_normal()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::execution_time_normal(this),
        _Internal::execution_time_normal(this).GetCachedSize(), target, stream);
  }

  // .tensorflow.LogNormalDistribution execution_time_log_normal = 11;
  if (_internal_has_execution_time_log_normal()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::execution_time_log_normal(this),
        _Internal::execution_time_log_normal(this).GetCachedSize(), target, stream);
  }

  // .tensorflow.SessionInfo session_info = 12 [deprecated = true];
  if (this->_internal_has_session_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::session_info(this),
        _Internal::session_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.OpPerformance)
  return target;
}

size_t OpPerformance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.OpPerformance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string node = 5;
  if (!this->_internal_node().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_node());
  }

  // .tensorflow.OpInfo op = 1;
  if (this->_internal_has_op()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.op_);
  }

  // .tensorflow.OpPerformance.OpMemory op_memory = 9;
  if (this->_internal_has_op_memory()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.op_memory_);
  }

  // .tensorflow.SessionInfo session_info = 12 [deprecated = true];
  if (this->_internal_has_session_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.session_info_);
  }

  // int64 temporary_memory_size = 2;
  if (this->_internal_temporary_memory_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_temporary_memory_size());
  }

  // int64 compute_cost = 3;
  if (this->_internal_compute_cost() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_compute_cost());
  }

  // double compute_efficiency = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_compute_efficiency = this->_internal_compute_efficiency();
  uint64_t raw_compute_efficiency;
  memcpy(&raw_compute_efficiency, &tmp_compute_efficiency, sizeof(tmp_compute_efficiency));
  if (raw_compute_efficiency != 0) {
    total_size += 1 + 8;
  }

  // int64 compute_time = 6;
  if (this->_internal_compute_time() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_compute_time());
  }

  // int64 memory_time = 7;
  if (this->_internal_memory_time() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_memory_time());
  }

  // double memory_efficiency = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_memory_efficiency = this->_internal_memory_efficiency();
  uint64_t raw_memory_efficiency;
  memcpy(&raw_memory_efficiency, &tmp_memory_efficiency, sizeof(tmp_memory_efficiency));
  if (raw_memory_efficiency != 0) {
    total_size += 1 + 8;
  }

  switch (execution_time_case()) {
    // .tensorflow.NormalDistribution execution_time_normal = 10;
    case kExecutionTimeNormal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.execution_time_.execution_time_normal_);
      break;
    }
    // .tensorflow.LogNormalDistribution execution_time_log_normal = 11;
    case kExecutionTimeLogNormal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.execution_time_.execution_time_log_normal_);
      break;
    }
    case EXECUTION_TIME_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OpPerformance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OpPerformance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OpPerformance::GetClassData() const { return &_class_data_; }


void OpPerformance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OpPerformance*>(&to_msg);
  auto& from = static_cast<const OpPerformance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.OpPerformance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_node().empty()) {
    _this->_internal_set_node(from._internal_node());
  }
  if (from._internal_has_op()) {
    _this->_internal_mutable_op()->::tensorflow::OpInfo::MergeFrom(
        from._internal_op());
  }
  if (from._internal_has_op_memory()) {
    _this->_internal_mutable_op_memory()->::tensorflow::OpPerformance_OpMemory::MergeFrom(
        from._internal_op_memory());
  }
  if (from._internal_has_session_info()) {
    _this->_internal_mutable_session_info()->::tensorflow::SessionInfo::MergeFrom(
        from._internal_session_info());
  }
  if (from._internal_temporary_memory_size() != 0) {
    _this->_internal_set_temporary_memory_size(from._internal_temporary_memory_size());
  }
  if (from._internal_compute_cost() != 0) {
    _this->_internal_set_compute_cost(from._internal_compute_cost());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_compute_efficiency = from._internal_compute_efficiency();
  uint64_t raw_compute_efficiency;
  memcpy(&raw_compute_efficiency, &tmp_compute_efficiency, sizeof(tmp_compute_efficiency));
  if (raw_compute_efficiency != 0) {
    _this->_internal_set_compute_efficiency(from._internal_compute_efficiency());
  }
  if (from._internal_compute_time() != 0) {
    _this->_internal_set_compute_time(from._internal_compute_time());
  }
  if (from._internal_memory_time() != 0) {
    _this->_internal_set_memory_time(from._internal_memory_time());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_memory_efficiency = from._internal_memory_efficiency();
  uint64_t raw_memory_efficiency;
  memcpy(&raw_memory_efficiency, &tmp_memory_efficiency, sizeof(tmp_memory_efficiency));
  if (raw_memory_efficiency != 0) {
    _this->_internal_set_memory_efficiency(from._internal_memory_efficiency());
  }
  switch (from.execution_time_case()) {
    case kExecutionTimeNormal: {
      _this->_internal_mutable_execution_time_normal()->::tensorflow::NormalDistribution::MergeFrom(
          from._internal_execution_time_normal());
      break;
    }
    case kExecutionTimeLogNormal: {
      _this->_internal_mutable_execution_time_log_normal()->::tensorflow::LogNormalDistribution::MergeFrom(
          from._internal_execution_time_log_normal());
      break;
    }
    case EXECUTION_TIME_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OpPerformance::CopyFrom(const OpPerformance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.OpPerformance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpPerformance::IsInitialized() const {
  return true;
}

void OpPerformance::InternalSwap(OpPerformance* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.node_, lhs_arena,
      &other->_impl_.node_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OpPerformance, _impl_.memory_efficiency_)
      + sizeof(OpPerformance::_impl_.memory_efficiency_)
      - PROTOBUF_FIELD_OFFSET(OpPerformance, _impl_.op_)>(
          reinterpret_cast<char*>(&_impl_.op_),
          reinterpret_cast<char*>(&other->_impl_.op_));
  swap(_impl_.execution_time_, other->_impl_.execution_time_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata OpPerformance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto[7]);
}

// ===================================================================

class OpPerformanceList::_Internal {
 public:
};

OpPerformanceList::OpPerformanceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:tensorflow.OpPerformanceList)
}
OpPerformanceList::OpPerformanceList(const OpPerformanceList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OpPerformanceList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.op_performance_){from._impl_.op_performance_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:tensorflow.OpPerformanceList)
}

inline void OpPerformanceList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.op_performance_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OpPerformanceList::~OpPerformanceList() {
  // @@protoc_insertion_point(destructor:tensorflow.OpPerformanceList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OpPerformanceList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.op_performance_.~RepeatedPtrField();
}

void OpPerformanceList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OpPerformanceList::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.OpPerformanceList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.op_performance_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpPerformanceList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .tensorflow.OpPerformance op_performance = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_op_performance(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OpPerformanceList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.OpPerformanceList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .tensorflow.OpPerformance op_performance = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_op_performance_size()); i < n; i++) {
    const auto& repfield = this->_internal_op_performance(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.OpPerformanceList)
  return target;
}

size_t OpPerformanceList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.OpPerformanceList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tensorflow.OpPerformance op_performance = 1;
  total_size += 1UL * this->_internal_op_performance_size();
  for (const auto& msg : this->_impl_.op_performance_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OpPerformanceList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OpPerformanceList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OpPerformanceList::GetClassData() const { return &_class_data_; }


void OpPerformanceList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OpPerformanceList*>(&to_msg);
  auto& from = static_cast<const OpPerformanceList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.OpPerformanceList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.op_performance_.MergeFrom(from._impl_.op_performance_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OpPerformanceList::CopyFrom(const OpPerformanceList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.OpPerformanceList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpPerformanceList::IsInitialized() const {
  return true;
}

void OpPerformanceList::InternalSwap(OpPerformanceList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.op_performance_.InternalSwap(&other->_impl_.op_performance_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OpPerformanceList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_getter, &descriptor_table_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto_once,
      file_level_metadata_tensorflow_2fcore_2fgrappler_2fcosts_2fop_5fperformance_5fdata_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace tensorflow
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::tensorflow::SessionInfo*
Arena::CreateMaybeMessage< ::tensorflow::SessionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::SessionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::OpInfo_AttrEntry_DoNotUse*
Arena::CreateMaybeMessage< ::tensorflow::OpInfo_AttrEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::OpInfo_AttrEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::OpInfo_TensorProperties*
Arena::CreateMaybeMessage< ::tensorflow::OpInfo_TensorProperties >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::OpInfo_TensorProperties >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::OpInfo*
Arena::CreateMaybeMessage< ::tensorflow::OpInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::OpInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::NormalDistribution*
Arena::CreateMaybeMessage< ::tensorflow::NormalDistribution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::NormalDistribution >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::LogNormalDistribution*
Arena::CreateMaybeMessage< ::tensorflow::LogNormalDistribution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::LogNormalDistribution >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::OpPerformance_OpMemory*
Arena::CreateMaybeMessage< ::tensorflow::OpPerformance_OpMemory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::OpPerformance_OpMemory >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::OpPerformance*
Arena::CreateMaybeMessage< ::tensorflow::OpPerformance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::OpPerformance >(arena);
}
template<> PROTOBUF_NOINLINE ::tensorflow::OpPerformanceList*
Arena::CreateMaybeMessage< ::tensorflow::OpPerformanceList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tensorflow::OpPerformanceList >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
